{
    "problem_name": "Multiparticle_dynamics_in_the_optical_tweezer_array",
    "problem_id": "32",
    "problem_description_main": "A system of $N$ identical nanospheres is trapped by an optical tweezer array that is arranged equidistantly along the $x$ axis. Each nanosphere is confined to oscillate near its equilibrium position because of the harmonic trapping forces from the linearly polarized optical tweezer array. The adjacent nanospheres interact via optical binding forces resulting from induced dipoles. Simulate the dynamics of phonon occupation using Python finctionalities for small oscillations along the $x$-axis near the equilibrium positions of each sphere.",
    "problem_background_main": "In an optical tweezer array, trapped nanospheres experience optical binding forces due to interactions between their induced dipoles and external fields. These forces, combined with damping and vibrational couplings, govern the dynamics of phonon occupation. This problem explores these dynamics by modeling the system as coupled harmonic oscillators.",
    "problem_io": "'''\nInput:\nN : int\n    Number of trapped nanospheres.\nt0 : float\n    Time point to compute phonon occupation.\nR : float\n    Distance between adjacent nanospheres.\nl : float\n    Wavelength of optical traps.\nphi : float\n    Polarization angle of the traps.\nGamma : float\n    Damping coefficient of nanospheres.\nP : list of floats\n    Power of optical traps for each nanosphere.\nn0 : list of floats\n    Initial phonon occupation numbers.\nw : float\n    Beam waist of optical traps.\na : float\n    Radius of nanospheres.\nn : float\n    Refractive index of nanospheres.\nrho : float\n    Density of nanospheres.\n\nOutput:\nnf : list of floats\n    Phonon occupation numbers at time t0.\n'''",
    "required_dependencies": "import numpy as np\nimport scipy\nfrom scipy.constants import epsilon_0, c",
    "sub_steps": [
        {
            "step_number": "32.1",
            "step_name": "Calculate Optical Binding Force",
            "step_description_prompt": "Two linearly polarized optical traps having the same polarization direction are separated by a distance $R$. Implement a Python function to compute the optical binding force between the two identical nanospheres trapped by a linearly polarized optical tweezer array. The function should calculate the induced dipole interactions between the two nanospheres, assuming the Rayleigh approximation.",
            "step_background": "The Rayleigh approximation can be considered to solve this problem as here each nanosphere functions as an induced dipole in the external field. The optical binding force arises from the interaction between the dipole induced in one nanosphere and the electric field generated by the induced dipole of the other nanosphere. This force is derived from the dyadic Green's function and depends on factors like polarization, inter-sphere distance (R), and beam parameters.",
            "function_header": "def calculate_binding_force(P, phi, R, l, w, a, n):",
            "ground_truth_code": "def calculate_binding_force(P, phi, R, l, w, a, n):\n    alpha = 4 * np.pi * epsilon_0 * a**3 * (n**2 - 1) / (n**2 + 2)\n    E1 = np.sqrt(4 * P[0] / (np.pi * w**2 * epsilon_0 * c))\n    E2 = np.sqrt(4 * P[1] / (np.pi * w**2 * epsilon_0 * c))\n    k = 2 * np.pi / l\n    F = (alpha**2 * E1 * E2 / (8 * np.pi * epsilon_0 * R**4)) * (\n        -3 * np.cos(k * R) - 3 * k * R * np.sin(k * R) + (k * R)**2 * np.cos(k * R)\n    )\n    return F", 
            "test_cases": [
            "# Test case 1 \n     P = [10e6, 100e6]  # Laser powers (W) \n     phi = 0  # Polarization angle (radians) \n     R = 1550e-9  # Distance between nanospheres (m) \n     l = 1550e-9  # Wavelength (m) \n     w = 600e-9  # Beam waist (m) \n     a = 100e-9  # Radius of nanospheres (m) \n     n = 1.444  # Refractive index \n     target = binding_force(P, phi, R, l, w, a, n) \n     assert np.isclose(binding_force(P, phi, R, l, w, a, n), target), (\n         f"Test case 1 failed. Expected {target}, got {binding_force(P, phi, R, l, w, a, n)}" \n     )"
            "# Test case 2 \n     P = [10e6, 100e6] \n     phi = np.pi / 2\n     R = 1550e-9 \n     l = 1550e-9 \n     w = 600e-9 \n     a = 100e-9 \n     n = 1.444 \n     target = binding_force(P, phi, R, l, w, a, n) \n     assert np.isclose(binding_force(P, phi, R, l, w, a, n), target), (\n         f"Test case 2 failed. Expected {target}, got {binding_force(P, phi, R, l, w, a, n)}" \n     )" \n
            "# Test case 3 \n     P = [1e9, 1e9] \n     phi = np.pi / 4 \n     R = 1550e-9 \n     l = 1550e-9 \n     w = 600e-9 \n     a = 100e-9 \n     n = 1.444 \n     target = binding_force(P, phi, R, l, w, a, n) \n     assert np.isclose(binding_force(P, phi, R, l, w, a, n), target), (\n         f"Test case 3 failed. Expected {target}, got {binding_force(P, phi, R, l, w, a, n)}" \n     )\n         "assert np.isclose(calculate_binding_force([1e-3, 1e-3], 0, 1.5e-6, 1.55e-6, 0.6e-6, 0.1e-6, 1.444), 2.089e-06)",\n "assert np.isclose(calculate_binding_force([1e-3, 2e-3], np.pi/4, 1e-6, 1.55e-6, 0.6e-6, 0.1e-6, 1.444), 3.472e-06)"
            ]
        },
        {
            "step_number": "32.2",
            "step_name": "Generate Hamiltonian",
            "step_description_prompt": "Write a Python function to compute the Hamiltonian of the provided nanosphere system, considering the linearized optical binding forces.",
            "step_background": "The Hamiltonian represents the coupled oscillatory system, incorporating resonant frequencies and coupling constants between nanospheres. These parameters are derived from linearized binding forces.",
            "function_header": "def generate_hamiltonian(P, phi, R, l, w, a, n, N, rho):",
            "ground_truth_code": "def generate_hamiltonian(P, phi, R, l, w, a, n, N, rho):\n    H = np.zeros((N, N))\n    m = (4/3) * np.pi * a**3 * rho\n    for i in range(N):\n        H[i, i] = np.sqrt(calculate_binding_force([P[i], P[i]], phi, R, l, w, a, n) / m)\n        if i > 0:\n            coupling = calculate_binding_force([P[i - 1], P[i]], phi, R, l, w, a, n)\n            H[i, i - 1] = H[i - 1, i] = -coupling / m\n    return H",
            "test_cases": [
            "# Test Case 1: 2 Nanospheres \n     P = [1e-3, 1e-3]  # Laser power (W) \n     phi = 0.0  # Polarization angle (radians) \n     R = 1e-6  # Distance (m) \n     l = 1.55e-6  # Wavelength (m) \n     w = 0.6e-6  # Beam waist (m) \n     a = 0.1e-6  # Radius (m) \n     n = 1.444  # Refractive index \n     rho = 2200  # Density (kg/mÂ³) \n     N = 2  # Number of nanospheres \n     # Call the function \n     H = generate_hamiltonian(P, phi, R, l, w, a, n, N, rho) \n     # Expected result \n     expected_H = np.array([ \n         [np.sqrt(1.0 / (4 / 3 * np.pi * a**3 * rho)), -1.0 / (4 / 3 * np.pi * a**3 * rho)], \n         [-1.0 / (4 / 3 * np.pi * a**3 * rho), np.sqrt(1.0 / (4 / 3 * np.pi * a**3 * rho))] \n  ]) \n     # Assert equality \n     assert np.allclose(H, expected_H, rtol=1e-4, atol=1e-6), "Test Case 1 Failed!" \n     print("Test Case 1 Passed!") "
            "# Test Case 2: 3 Nanospheres \n     N = 3 \n     H = generate_hamiltonian(P * N, phi, R, l, w, a, n, N, rho) \n     # Expected result for 3 nanospheres \n     expected_H = np.zeros((3, 3)) \n     for i in range(3): \n         expected_H[i, i] = np.sqrt(1.0 / (4 / 3 * np.pi * a**3 * rho)) \n     expected_H[0, 1] = expected_H[1, 0] = expected_H[1, 2] = expected_H[2, 1] = -1.0 / (4 / 3 * np.pi * a**3 * rho) \n    # Assert equality \n     assert np.allclose(H, expected_H, rtol=1e-4, atol=1e-6), "Test Case 2 Failed!" \n     print("Test Case 2 Passed!")"                       
            ]
        },
        {
            "step_number": "32.3",
            "step_name": "Runge-Kutta for Phonon Dynamics",
            "step_description_prompt": "Write a Python function to implement the fourth-order Runge-Kutta (RK4) method to simulate phonon occupation dynamics in the Lindblad form. Implement the model on different scenarios of Phonon occupation in the nanosphare system, starting with simplified case without any dynamics. Then simulate the Hamiltonian-driven dynamics followed by dissipative dynamics that takes into account the damping function. Finally, study the combined effects of Hamiltonian and dissipative dynamics of Phonon occupation within the described system by implementing RK4 model.",
            "step_background": "The Lindblad master equation describes the evolution of the correlation matrix under dissipation and external fields. The RK4 method numerically integrates this equation.",
            "function_header": "def runge_kutta_dynamics(C0, H, L, M, t0, steps):",
            "ground_truth_code": "def runge_kutta_dynamics(C0, H, L, M, t0, steps):\n    dt = t0 / steps\n    C = C0\n    for _ in range(steps):\n        k1 = dt * (1j * (H @ C - C @ H) + L @ C + M)\n        k2 = dt * (1j * (H @ (C + 0.5 * k1) - (C + 0.5 * k1) @ H) + L @ (C + 0.5 * k1) + M)\n        k3 = dt * (1j * (H @ (C + 0.5 * k2) - (C + 0.5 * k2) @ H) + L @ (C + 0.5 * k2) + M)\n        k4 = dt * (1j * (H @ (C + k3) - (C + k3) @ H) + L @ (C + k3) + M)\n        C += (k1 + 2 * k2 + 2 * k3 + k4) / 6\n    return np.diagonal(C)",
            "test_cases": [
            "# Test Case 1: Simplified case with no dynamics \n     C0 = np.array([[1.0, 0.0], [0.0, 0.0]], dtype=complex) \n     H = np.zeros((2, 2), dtype=complex)  # Zero Hamiltonian \n     L = np.zeros((2, 2), dtype=complex)  # Zero dissipative operator \n     M = np.zeros((2, 2), dtype=complex)  # Zero driving matrix \n     t0 = 1.0 \n     steps = 100 \n     expected = C0 \n     result = runge_kutta_dynamics(C0, H, L, M, t0, steps) \n     assert np.allclose(result, expected, rtol=1e-4, atol=1e-6), f"Test Case 1 Failed! Expected {expected}, got {result}." \n     print("Test Case 1 Passed!") "
            "# Test Case 2: Simple Hamiltonian-driven dynamics \n     C0 = np.array([[1.0, 0.0], [0.0, 0.0]], dtype=complex) \n     H = np.array([[0.0, 1.0], [1.0, 0.0]], dtype=complex)  # Off-diagonal Hamiltonian \n     L = np.zeros((2, 2), dtype=complex)  # Zero dissipative operator \n     M = np.zeros((2, 2), dtype=complex)  # Zero driving matrix \n     t0 = np.pi  # Evolution time corresponding to a quarter period \n     steps = 100 \n     # Run the function \n    result = runge_kutta_dynamics(C0, H, L, M, t0, steps) \n     # Numerical validation using symmetry and trace conservation \n     result_trace = result.trace()  # Compute trace of the result \n    initial_trace = C0.trace()  # Compute trace of the initial state \n     assert np.isclose(result_trace, initial_trace, atol=1e-6), ( \n         f"Trace mismatch! Expected {initial_trace}, got {result_trace}." \n  ) \n    print("Test Case 2 Passed (Numerical Validation)!")" 
            "# Test Case 3: Dissipative dynamics \n     C0 = np.eye(2, dtype=complex)  # Initial correlation matrix \n     H = np.zeros((2, 2), dtype=complex)  # No Hamiltonian dynamics \n     L = np.array([[0.1, 0.0], [0.0, 0.2]], dtype=complex)  # Simple damping matrix \n     M = np.zeros((2, 2), dtype=complex)  # No driving \n     t0 = 1.0  # Total evolution time \n     steps = 100 \n     # Run the function \n     result = runge_kutta_dynamics(C0, H, L, M, t0, steps) \n     # Validate against expected decay: exp(-t0 * L[i, i]) \n     expected = np.diag([np.exp(-t0 * L[0, 0]), np.exp(-t0 * L[1, 1])]) \n     # Compare result to expected values \n     assert np.allclose(np.diag(result), np.diag(expected), rtol=1e-4, atol=1e-6), ( \n         f"Test Case 3 Failed! Expected {expected}, got {result}." \n    ) \n     print("Test Case 3 Passed!") "
            "# Test Case 4: Driving matrix effects \n     C0 = np.zeros((2, 2), dtype=complex)  # Initial zero matrix \n     H = np.zeros((2, 2), dtype=complex)  # Zero Hamiltonian \n     L = np.zeros((2, 2), dtype=complex)  # Zero dissipative operator \n     M = np.array([[0.0, 0.1], [0.1, 0.0]], dtype=complex)  # Off-diagonal driving term \n     t0 = 1.0 \n     steps = 100 \n     expected = M * t0  # Linear growth approximation for small t\n     result = runge_kutta_dynamics(C0, H, L, M, t0, steps) \n     assert np.allclose(result, expected, rtol=1e-4, atol=1e-6), f"Test Case 4 Failed! Expected {expected}, got {result}." \n     print("Test Case 4 Passed!")"
            "# Test Case 5: Combined effects \n     C0 = np.eye(2, dtype=complex) * 0.5  # Diagonal initial condition \n     H = mock_hamiltonian(2)  # Mock Hamiltonian \n     L = mock_dissipative_operator(2)  # Mock dissipative operator \n     M = mock_driving_matrix(2)  # Mock driving matrix \n     t0 = 2.0 \n     steps = 100 \n     result = runge_kutta_dynamics(C0, H, L, M, t0, steps) \n    print("Test Case 5 Result:", result) \n     print("Test Case 5 Passed! (Verification may require numerical analysis)") \n   "assert np.isclose(runge_kutta_dynamics([...]), target)", \n  "assert np.isclose(runge_kutta_dynamics([...]), target)"  ]
        }
    ],
    "general_tests": [
        "n0 = [39549953.17, 197.25, 197.25, 197.25, 197.25]\nGamma = 0.001\nP = [100e-3, 100e-3, 100e-3, 100e-3, 100e-3]\nphi = np.pi / 2\nR = 0.99593306197 * 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\nh = 1e-6\nN = np.size(P)\nrho = 2.648e3\nC0 = np.diag(n0)\nH = generate_Hamiltonian(P, phi, R, l, w, a, n, h, N, rho)\nL = - Gamma * np.identity(N) / 2\nM = 197.25 * Gamma * np.identity(N) / 2\nt0 = 0.02\nsteps = 100000\nassert np.allclose(runge_kutta(C0, H, L, M, t0, steps), target)",
        "n0 = [197.25, 39549953.17, 39549953.17, 39549953.17, 39549953.17]\nGamma = 0.001\nP = [100e-3, 100e-3, 100e-3, 100e-3, 100e-3]\nphi = np.pi / 2\nR = 0.99593306197 * 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\nh = 1e-6\nN = np.size(P)\nrho = 2.648e3\nC0 = np.diag(n0)\nH = generate_Hamiltonian(P, phi, R, l, w, a, n, h, N, rho)\nL = - Gamma * np.identity(N) / 2\nM = 197.25 * Gamma * np.identity(N) / 2\nt0 = 0.05\nsteps = 100000\nassert np.allclose(runge_kutta(C0, H, L, M, t0, steps), target)",
        "n0 = [39549953.17, 197.25, 197.25, 197.25, 197.25]\nGamma = 0.001\nP = [100e-3, 100e-3, 100e-3, 100e-3, 100e-3]\nphi = np.pi / 2\nR = 0.99593306197 * 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\nh = 1e-6\nN = np.size(P)\nrho = 2.648e3\nC0 = np.diag(n0)\nH = generate_Hamiltonian(P, phi, R, l, w, a, n, h, N, rho)\nL = - Gamma * np.identity(N) / 2\nM = 197.25 * Gamma * np.identity(N) / 2\nt0 = 0.05\nsteps = 100000\nassert np.allclose(runge_kutta(C0, H, L, M, t0, steps), target)",
        "n0 = [197.25, 197.25, 39549953.17, 197.25, 197.25]\nGamma = 0\nP = [100e-3, 100e-3, 100e-3, 100e-3, 100e-3]\nphi = np.pi / 2\nR = 0.99593306197 * 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\nh = 1e-6\nN = np.size(P)\nrho = 2.648e3\nC0 = np.diag(n0)\nH = generate_Hamiltonian(P, phi, R, l, w, a, n, h, N, rho)\nL = - Gamma * np.identity(N) / 2\nM = 197.25 * Gamma * np.identity(N) / 2\nt0 = 0.02\nsteps = 100000\nnf = runge_kutta(C0, H, L, M, t0, steps)\ndiff = sum(nf) - sum(n0)\ndef is_symmetric(array, rtol=1e-05, atol=1e-08):\n    return np.all(np.isclose(array, array[::-1], rtol=rtol, atol=atol))\nassert (abs(diff)<1e-6, is_symmetric(nf)) == target"
        "assert np.allclose(simulate_phonon_dynamics([...]), target)"
    ],
}
