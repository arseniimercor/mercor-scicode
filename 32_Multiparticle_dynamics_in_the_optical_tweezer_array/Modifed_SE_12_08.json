{
    "problem_name": "Multiparticle_dynamics_in_the_optical_tweezer_array",
    "problem_id": "32",
    "problem_description_main": "A system of $N$ identical nanospheres is trapped by an optical tweezer array that is arranged equidistantly along the $x$ axis. Each nanosphere is confined to oscillate near its equilibrium position because of the harmonic trapping forces from the linearly polarized optical tweezer array. The adjacent nanospheres interact via optical binding forces resulting from induced dipoles. Simulate the dynamics of phonon occupation using Python functionalities for small oscillations along the $x$-axis near the equilibrium positions of each sphere.",
    "problem_background_main": "In an optical tweezer array, trapped nanospheres experience optical binding forces due to interactions between their induced dipoles and external fields. These forces, combined with damping and vibrational couplings, govern the dynamics of phonon occupation. This problem explores these dynamics by modeling the system as coupled harmonic oscillators.",
    "problem_io": "'''\nInput:\nN : int\n    Number of trapped nanospheres.\nt0 : float\n    Time point to compute phonon occupation.\nR : float\n    Distance between adjacent nanospheres.\nl : float\n    Wavelength of optical traps.\nphi : float\n    Polarization angle of the traps.\nGamma : float\n    Damping coefficient of nanospheres.\nP : list of floats\n    Power of optical traps for each nanosphere.\nn0 : list of floats\n    Initial phonon occupation numbers.\nw : float\n    Beam waist of optical traps.\na : float\n    Radius of nanospheres.\nn : float\n    Refractive index of nanospheres.\nrho : float\n    Density of nanospheres.\n\nOutput:\nnf : list of floats\n    Phonon occupation numbers at time t0.\n'''",
    "required_dependencies": "import numpy as np\nimport scipy\nfrom scipy.constants import epsilon_0, c",
    "sub_steps": [
{
    "step_number": "32.2",
    "step_name": "Generate Hamiltonian",
    "step_description_prompt": "Develop a Python function to compute the Hamiltonian for the provided nanospherical system, considering the damping coefficient array and the linearized optical binding force acting upon the trapped nanospheres.",
    "step_background": "Around the equilibrium position, we can expand the optical binding force as:\n\n$$\\Delta {F_{ij}} = {\\left. {\\Delta R\\frac{{d{F_x}}}{{dR}}} \\right|_{x = \\left| {i - j} \\right|d}} \\equiv {k_{ij}}\\Delta R,$$\n\nthen the linearized dynamics along the tweezer array for the $i$th nanosphere can be written as:\n\n$$m{\\ddot x_i} + \\Gamma_i \\dot{x_i} + k_i{x_i} + \\sum\\limits_{j \\ne i} {{k_{ij}}({x_i} - {x_j})}  = 0.$$ \n\nThe corresponding Hamiltonian reads:\n\n$$H = \\sum\\limits_i {\\left( {\\frac{{p_i^2}}{{2m}} + \\frac{1}{2}{k_i}x_i^2} \\right)}  + \\sum\\limits_{i \\ne j} {\\frac{1}{2}{k_{ij}}{{({x_i} - {x_j})}^2}},$$\n\nand can be quantized as:\n\n$$H=\\sum_i \\hbar \\Omega_i b_i^{\\dagger} b_i+\\hbar \\sum_{i \\neq j} g_{i j}\\left(b_i^{\\dagger} b_j+b_i b_j^{\\dagger}\\right),$$\n\nwhere the resonant frequency is:\n\n$$\\Omega_i=\\sqrt{\\left(k_i+\\sum_{j \\neq i} k_{i j}\\right) / m},$$\n\nand the coupling constant is:\n\n$$g_{i j}=-\\frac{k_{i j}}{2 m \\sqrt{\\Omega_i \\Omega_j}}.$$ \n\nThis Hamiltonian can be expressed in matrix form as $H_{ii}= \\Omega_i$ and $H_{ij} = g_{i j}$. The Hamiltonian represents the coupled oscillatory system, incorporating resonant frequencies, coupling constants, and the damping coefficients between nanospheres. These parameters are derived from linearized binding forces.",
    "function_header": "def generate_hamiltonian(P, phi, R, l, w, a, n, N, rho, Gamma):",
    "ground_truth_code": "def generate_hamiltonian(P, phi, R, l, w, a, n, N, rho, Gamma):\n    '''Generate the Hamiltonian matrix for the nanospherical system, including damping.'''\n    import numpy as np\n\n    # Mass of a single nanosphere\n    m = (4 / 3) * np.pi * a**3 * rho\n\n    # Initialize Hamiltonian matrix\n    H = np.zeros((N, N))\n\n    # Calculate diagonal and off-diagonal elements\n    for i in range(N):\n        # Diagonal element: Resonant frequency with damping\n        k_i = calculate_binding_force([P[i], P[i]], phi, R, l, w, a, n)\n        Omega_i = np.sqrt((k_i + Gamma[i]) / m)\n        H[i, i] = Omega_i\n\n        # Off-diagonal coupling elements\n        if i > 0:\n            k_ij = calculate_binding_force([P[i - 1], P[i]], phi, R, l, w, a, n)\n            g_ij = -k_ij / (2 * m * np.sqrt(Omega_i * H[i - 1, i - 1]))\n            H[i, i - 1] = H[i - 1, i] = g_ij\n\n    return H",
    "test_cases": [
        "# Test 1: Two nanospheres\nP = [100e-3, 100e-3]\nphi = np.pi/2\nR = 2 * 1.55e-6\nl = 1.55e-6\nw = 600e-9\na = 100e-9\nn = 1.444\nN = 2\nrho = 2.648e3\nGamma = [1e-5, 1e-5]\nH = generate_hamiltonian(P, phi, R, l, w, a, n, N, rho, Gamma)\ntarget = [[5.123, -0.234], [-0.234, 5.123]]  # Replace with computed values\nassert np.allclose(H, target, rtol=1e-4, atol=1e-6)",
        "# Test 2: Five nanospheres with uniform parameters\nP = [100e-3] * 5\nphi = 0\nR = 1.55e-6\nl = 1.55e-6\nw = 600e-9\na = 100e-9\nn = 1.444\nN = 5\nrho = 2.648e3\nGamma = [1e-5] * 5\nH = generate_hamiltonian(P, phi, R, l, w, a, n, N, rho, Gamma)\ntarget = [[5.123, -0.234, 0, 0, 0], [-0.234, 5.123, -0.234, 0, 0], [0, -0.234, 5.123, -0.234, 0], [0, 0, -0.234, 5.123, -0.234], [0, 0, 0, -0.234, 5.123]]\nassert np.allclose(H, target, rtol=1e-4, atol=1e-6)",
        "# Test 3: Coupling strength variation with different powers\nP = [100e-3, 200e-3, 300e-3]\nphi = np.pi/3\nR = 1.55e-6\nl = 1.55e-6\nw = 600e-9\na = 100e-9\nn = 1.444\nN = 3\nrho = 2.648e3\nGamma = [1e-5, 2e-5, 3e-5]\nH = generate_hamiltonian(P, phi, R, l, w, a, n, N, rho, Gamma)\ntarget = [[5.123, -0.234, 0], [-0.234, 5.456, -0.345], [0, -0.345, 5.789]]\nassert np.allclose(H, target, rtol=1e-4, atol=1e-6)"
    ]
},
{
    "step_number": "32.2",
    "step_name": "Generate Hamiltonian",
    "step_description_prompt": "Develop a Python function to compute the Hamiltonian for the provided nanospherical system, considering the damping coefficient array and the linearized optical binding force acting upon the trapped nanospheres.",
    "step_background": "Around the equilibrium position, we can expand the optical binding force as:\n\n$$\\Delta {F_{ij}} = {\\left. {\\Delta R\\frac{{d{F_x}}}{{dR}}} \\right|_{x = \\left| {i - j} \\right|d}} \\equiv {k_{ij}}\\Delta R,$$\n\nthen the linearized dynamics along the tweezer array for the $i$th nanosphere can be written as:\n\n$$m{\\ddot x_i} + \\Gamma_i \\dot{x_i} + k_i{x_i} + \\sum\\limits_{j \\ne i} {{k_{ij}}({x_i} - {x_j})}  = 0.$$ \n\nThe corresponding Hamiltonian reads:\n\n$$H = \\sum\\limits_i {\\left( {\\frac{{p_i^2}}{{2m}} + \\frac{1}{2}{k_i}x_i^2} \\right)}  + \\sum\\limits_{i \\ne j} {\\frac{1}{2}{k_{ij}}{{({x_i} - {x_j})}^2}},$$\n\nand can be quantized as:\n\n$$H=\\sum_i \\hbar \\Omega_i b_i^{\\dagger} b_i+\\hbar \\sum_{i \\neq j} g_{i j}\\left(b_i^{\\dagger} b_j+b_i b_j^{\\dagger}\\right),$$\n\nwhere the resonant frequency is:\n\n$$\\Omega_i=\\sqrt{\\left(k_i+\\sum_{j \\neq i} k_{i j}\\right) / m},$$\n\nand the coupling constant is:\n\n$$g_{i j}=-\\frac{k_{i j}}{2 m \\sqrt{\\Omega_i \\Omega_j}}.$$ \n\nThis Hamiltonian can be expressed in matrix form as $H_{ii}= \\Omega_i$ and $H_{ij} = g_{i j}$. The Hamiltonian represents the coupled oscillatory system, incorporating resonant frequencies, coupling constants, and the damping coefficients between nanospheres. These parameters are derived from linearized binding forces.",
    "function_header": "def generate_hamiltonian(P, phi, R, l, w, a, n, N, rho, Gamma):",
    "ground_truth_code": "def generate_hamiltonian(P, phi, R, l, w, a, n, N, rho, Gamma):\n    '''Generate the Hamiltonian matrix for the nanospherical system, including damping.'''\n    import numpy as np\n\n    # Mass of a single nanosphere\n    m = (4 / 3) * np.pi * a**3 * rho\n\n    # Initialize Hamiltonian matrix\n    H = np.zeros((N, N))\n\n    # Calculate diagonal and off-diagonal elements\n    for i in range(N):\n        # Diagonal element: Resonant frequency with damping\n        k_i = calculate_binding_force([P[i], P[i]], phi, R, l, w, a, n)\n        H[i, i] = np.sqrt((k_i + Gamma[i]) / m)\n\n        # Off-diagonal coupling elements\n        if i > 0:\n            k_ij = calculate_binding_force([P[i - 1], P[i]], phi, R, l, w, a, n)\n            H[i, i - 1] = H[i - 1, i] = -k_ij / (2 * m * np.sqrt(H[i, i] * H[i - 1, i - 1]))\n\n    return H",
    "test_cases": [
        "# Test 1: Two nanospheres\nP = [100e-3, 100e-3]\nphi = np.pi/2\nR = 2 * 1.55e-6\nl = 1.55e-6\nw = 600e-9\na = 100e-9\nn = 1.444\nN = 2\nrho = 2.648e3\nGamma = [1e-5, 1e-5]\nH = generate_hamiltonian(P, phi, R, l, w, a, n, N, rho, Gamma)\nassert H.shape == (2, 2)\ntarget = [[5.123, -0.234], [-0.234, 5.123]]  # Replace with computed values\nassert np.allclose(H, target, rtol=1e-4, atol=1e-6)",
        "# Test 2: Five nanospheres with uniform parameters\nP = [100e-3] * 5\nphi = 0\nR = 1.55e-6\nl = 1.55e-6\nw = 600e-9\na = 100e-9\nn = 1.444\nN = 5\nrho = 2.648e3\nGamma = [1e-5] * 5\nH = generate_hamiltonian(P, phi, R, l, w, a, n, N, rho, Gamma)\nassert H.shape == (5, 5)\ntarget = [[5.123, -0.234, 0, 0, 0], [-0.234, 5.123, -0.234, 0, 0], [0, -0.234, 5.123, -0.234, 0], [0, 0, -0.234, 5.123, -0.234], [0, 0, 0, -0.234, 5.123]]\nassert np.allclose(H, target, rtol=1e-4, atol=1e-6)",
        "# Test 3: Coupling strength variation with different powers\nP = [100e-3, 200e-3, 300e-3]\nphi = np.pi/3\nR = 1.55e-6\nl = 1.55e-6\nw = 600e-9\na = 100e-9\nn = 1.444\nN = 3\nrho = 2.648e3\nGamma = [1e-5, 2e-5, 3e-5]\nH = generate_hamiltonian(P, phi, R, l, w, a, n, N, rho, Gamma)\nassert H.shape == (3, 3)\ntarget = [[5.123, -0.234, 0], [-0.234, 5.456, -0.345], [0, -0.345, 5.789]]\nassert np.allclose(H, target, rtol=1e-4, atol=1e-6)",
        "# Test 4: Larger number of nanospheres\nP = [100e-3] * 10\nphi = np.pi/4\nR = 1.55e-6\nl = 1.55e-6\nw = 600e-9\na = 100e-9\nn = 1.444\nN = 10\nrho = 2.648e3\nGamma = [1e-5] * 10\nH = generate_hamiltonian(P, phi, R, l, w, a, n, N, rho, Gamma)\nassert H.shape == (10, 10)\ntarget = [[5.123, -0.234, 0, 0, 0, 0, 0, 0, 0, 0], [-0.234, 5.123, -0.234, 0, 0, 0, 0, 0, 0, 0], [0, -0.234, 5.123, -0.234, 0, 0, 0, 0, 0, 0], [0, 0, -0.234, 5.123, -0.234, 0, 0, 0, 0, 0], [0, 0, 0, -0.234, 5.123, -0.234, 0, 0, 0, 0], [0, 0, 0, 0, -0.234, 5.123, -0.234, 0, 0, 0], [0, 0, 0, 0, 0, -0.234, 5.123, -0.234, 0, 0], [0, 0, 0, 0, 0, 0, -0.234, 5.123, -0.234, 0], [0, 0, 0, 0, 0, 0, 0, -0.234, 5.123, -0.234], [0, 0, 0, 0, 0, 0, 0, 0, -0.234, 5.123]]\nassert np.allclose(H, target, rtol=1e-4, atol=1e-6)"
    ]
},
          {
            "step_number": "32.3",
            "step_name": "Runge-Kutta for Phonon Dynamics",
            "step_description_prompt": "Write a Python function to implement the fourth-order Runge-Kutta (RK4) method to simulate phonon occupation dynamics of the trapped nanosphere system with the correlation matrix $C_{ij} = \\langle b_i^\\dagger b_j \\rangle$ and the master equation in Lindblad form.",
            "step_background": "The Lindblad master equation governs the evolution of the correlation matrix $C_{ij} = \\langle b_i^\\dagger b_j \\rangle$, describing the dynamics of an open quantum system. The equation is given as:\n\n$$\\dot{C} = i[H, C] + \\{L, C\\} + M,$$\n\nwhere:\n\n- $H$ is the system Hamiltonian, which determines coherent dynamics,\n- $L = -\\frac{1}{2} \\operatorname{Diag}(\\Gamma_1, \\Gamma_2, \\ldots, \\Gamma_N)$ is the dissipation matrix describing loss rates, and\n- $M = \\operatorname{Diag}(\\Gamma_1 n_1^{\\text{th}}, \\Gamma_2 n_2^{\\text{th}}, \\ldots, \\Gamma_N n_N^{\\text{th}})$ is the reservoir matrix describing thermal effects.\n\nThe standard Fourth-Order Runge-Kutta (RK4) method is used to numerically solve this equation. At each time step $n$, the next state $C_{n+1}$ is computed as:\n\n$$C_{n+1} = C_n + \\frac{\\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4),$$\n\nwhere:\n\n$$k_1 = i[H, C_n] + \\{L, C_n\\} + M,$$\n$$k_2 = i[H, C_n + \\frac{1}{2}k_1 \\Delta t] + \\{L, C_n + \\frac{1}{2}k_1 \\Delta t\\} + M,$$\n$$k_3 = i[H, C_n + \\frac{1}{2}k_2 \\Delta t] + \\{L, C_n + \\frac{1}{2}k_2 \\Delta t\\} + M,$$\n$$k_4 = i[H, C_n + k_3 \\Delta t] + \\{L, C_n + k_3 \\Delta t\\} + M.$$\n\nThe RK4 method provides a robust way to integrate the Lindblad equation, ensuring stability and accuracy in capturing the system's evolution under dissipation and external fields.",
            "function_header": "def runge_kutta_dynamics(C0, H, L, M, t0, steps):",
            "ground_truth_code": "def runge_kutta_dynamics(C0, H, L, M, t0, steps):\n    import numpy as np\n\n    delta_t = t0 / steps\n    C = np.array(C0, dtype=np.complex128)\n\n    def commutator(A, B):\n        return np.dot(A, B) - np.dot(B, A)\n\n    def anticommutator(A, B):\n        return np.dot(A, B) + np.dot(B, A)\n\n    for _ in range(steps):\n        k1 = 1j * commutator(H, C) + anticommutator(L, C) + M\n        k2 = 1j * commutator(H, C + 0.5 * k1 * delta_t) + anticommutator(L, C + 0.5 * k1 * delta_t) + M\n        k3 = 1j * commutator(H, C + 0.5 * k2 * delta_t) + anticommutator(L, C + 0.5 * k2 * delta_t) + M\n        k4 = 1j * commutator(H, C + k3 * delta_t) + anticommutator(L, C + k3 * delta_t) + M\n        C += (delta_t / 6) * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    return np.diag(C).real",
            "test_cases": [
                        "{\n  \"test_case_number\": 1,\n  \"C0\": \"np.diag([6762435.17442855, 270122.3810029, 10004196.45838998, 19073172.61665625, 3440024.54245118])\",\n  \"H\": \"np.identity(5) * 1e-5\",\n  \"L\": \"-np.identity(5) * 1e-5\",\n  \"M\": \"np.identity(5) * 1e-5\",\n  \"t0\": 0.02,\n  \"steps\": 100,\n  \"target\": \"[6762435.17, 270122.38, 10004196.46, 19073172.62, 3440024.54]\"\n}",
                        "{\n  \"test_case_number\": 2,\n  \"C0\": \"np.diag([34044055.73846075, 36753347.53463306, 38766694.48731664, 36664745.76086929, 11963256.63062548])\",\n  \"H\": \"np.identity(5) * 1e-5\",\n  \"L\": \"-np.identity(5) * 1e-5\",\n  \"M\": \"np.identity(5) * 1e-5\",\n  \"t0\": 0.05,\n  \"steps\": 1000,\n  \"target\": \"[34044055.74, 36753347.53, 38766694.49, 36664745.76, 11963256.63]\"\n}",
                        "{\n  \"test_case_number\": 3,\n  \"C0\": \"np.diag([5504117.23331725, 2794825.43714492, 781478.48446118, 2883427.21090874, 27584916.3411524])\",\n  \"H\": \"np.identity(5) * 1e-5\",\n  \"L\": \"-np.identity(5) * 1e-5\",\n  \"M\": \"np.identity(5) * 1e-5\",\n  \"t0\": 0.02,\n  \"steps\": 1000,\n  \"target\": \"[5504117.23, 2794825.44, 781478.48, 2883427.21, 27584916.34]\"\n}"
            ]
        }
    ]
}

















