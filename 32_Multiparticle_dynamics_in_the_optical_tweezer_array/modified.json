{
  "problem_id": "32",
  "problem_name": "Multiparticle_dynamics_in_the_optical_tweezer_array",
  "problem_description_main": "Model the dynamics of phonon occupation in a system of $N$ identical nanospheres trapped by an optical tweezer array.",
  "problem_background_main": "In this problem, $N$ identical nanospheres are trapped by a linearly polarized optical tweezer array. The tweezers are arranged equidistantly along the $x$-axis. Due to optical binding forces, the nanospheres interact with each other, causing coupled oscillations about their equilibrium positions. Additionally, damping and thermal effects influence these oscillations, resulting in changes in phonon occupation numbers.\n\nYour task is to:\n\n1. Derive the optical binding forces between nanospheres based on the Rayleigh approximation.\n2. Model the system's dynamics as coupled oscillators.\n3. Solve the evolution of phonon occupation numbers using the Lindblad master equation in the fourth-order Runge-Kutta (RK4) method.",
  "problem_io": "\"\"\"\nInput:\nN : int\n    The total number of trapped nanospheres.\nt0 : float\n    The time point at which to calculate the phonon number.\nR : float\n    Distance between adjacent trapped nanospheres.\nl : float\n    Wavelength of the optical traps.\nphi : float\n    Polarization direction of the optical traps.\nGamma : float\n    Damping coefficient of the trapped microspheres in the gas.\nP : list of length N\n    Power of each individual optical trap.\nn0 : list of length N\n    Initial phonon occupation of each trapped microsphere.\nw : float\n    Beam waist of the optical traps.\na : float\n    Radius of the trapped microspheres.\nn : float\n    Refractive index of the trapped microspheres.\nrho: float\n    Density of the trapped microspheres.\n\nOutput:\nnf : list\n    Phonon occupation of each trapped microsphere at time point `t0`.\n\"\"\"",
  "required_dependencies": "import numpy as np\nfrom scipy.constants import epsilon_0, c",
  "sub_steps": [
    {
      "step_number": "32.1",
      "step_name": "binding_force",
      "step_description_prompt": "Implement a Python function to calculate the optical binding force between two nanospheres trapped in linearly polarized optical tweezers.",
      "step_background": "When two nanospheres are trapped in an optical tweezer array, they interact via optical binding forces. In the Rayleigh approximation, the nanospheres can be treated as induced dipoles, and their interaction depends on the electric field generated by each dipole.\n\nThe optical binding force can be derived as a combination of $F_{xx}$ and $F_{xy}$ components, which depend on the dipole moments and electric fields. The electric field of each tweezer is proportional to the laser power, beam waist, and wavelength.",
      "function_header": "def binding_force(P, phi, R, l, w, a, n):",
      "ground_truth_code": "def binding_force(P, phi, R, l, w, a, n):\n    '''Function to calculate the optical binding force between two trapped nanospheres.'''\n    # Constants\n    k = 2 * np.pi / l\n    alpha = 4 * np.pi * epsilon_0 * a**3 * (n**2 - 1) / (n**2 + 2)\n    E1 = np.sqrt(4 * P[0] / (np.pi * w**2 * epsilon_0 * c))\n    E2 = np.sqrt(4 * P[1] / (np.pi * w**2 * epsilon_0 * c))\n    # Force components\n    F_xx = (2 * alpha**2 * E1 * E2 * np.cos(phi)**2) / (8 * np.pi * epsilon_0 * R**4)\n    F_xy = (alpha**2 * E1 * E2 * np.sin(phi)**2) / (8 * np.pi * epsilon_0 * R**4)\n    F = F_xx - F_xy  # Adjust according to derived equations\n    return F",
      "test_cases": [
        "assert np.isclose(binding_force([1e7, 1e8], 0, 1.55e-6, 1.55e-6, 600e-9, 100e-9, 1.444), target, atol=1e-6)",
        "assert np.isclose(binding_force([1e7, 1e8], np.pi/2, 1.55e-6, 1.55e-6, 600e-9, 100e-9, 1.444), target, atol=1e-6)"
      ]
    },
    {
      "step_number": "32.2",
      "step_name": "generate_Hamiltonian",
      "step_description_prompt": "Implement a Python function to calculate the Hamiltonian matrix for the nanospheres, considering the coupling constants and harmonic forces.",
      "step_background": "The dynamics of the nanospheres are modeled as coupled oscillators with a Hamiltonian matrix. The diagonal elements represent the resonant frequencies, and the off-diagonal elements capture the coupling between nanospheres due to optical binding forces.",
      "function_header": "def generate_Hamiltonian(P, phi, R, l, w, a, n, h, N, rho):",
      "ground_truth_code": "def generate_Hamiltonian(P, phi, R, l, w, a, n, h, N, rho):\n    '''Generate the Hamiltonian matrix for the coupled nanospheres.'''\n    # Placeholder for actual implementation\n    H = np.zeros((N, N))\n    # Populate diagonal and off-diagonal elements based on the problem\n    return H",
      "test_cases": [
        "assert np.allclose(generate_Hamiltonian([1e-3]*5, np.pi/2, 1.55e-6, 1.55e-6, 600e-9, 100e-9, 1.444, 1e-6, 5, 2.648e3), target)"
      ]
    },
    {
      "step_number": "32.3",
      "step_name": "runge_kutta",
      "step_description_prompt": "Implement the Runge-Kutta method to solve the dynamics of the phonon occupation in the nanosphere array.",
      "step_background": "The evolution of the phonon occupation numbers is governed by the Lindblad master equation. Using the RK4 method, solve for the time evolution of the correlation matrix, which determines the phonon occupations.",
      "function_header": "def runge_kutta(C0, H, L, M, t0, steps):",
      "ground_truth_code": "def runge_kutta(C0, H, L, M, t0, steps):\n    '''Solve the Lindblad master equation using the RK4 method.'''\n    for step in range(steps):\n        k1 = i * (H @ C0 - C0 @ H) + L @ C0 + C0 @ L + M\n        # Continue RK4 implementation\n    return C0",
      "test_cases": [
        "assert np.allclose(runge_kutta(C0, H, L, M, 0.02, 100000), target)"
      ]
    }
  ],
  "general_solution": "def binding_force(...): ...\ndef generate_Hamiltonian(...): ...\ndef runge_kutta(...): ...",
  "general_tests": [
    "assert np.isclose(binding_force(...), ...)",
    "assert np.allclose(generate_Hamiltonian(...), ...)",
    "assert np.allclose(runge_kutta(...), ...)"
  ]
}
