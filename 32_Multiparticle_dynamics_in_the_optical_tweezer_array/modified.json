{
  "problem_id": "32",
  "problem_name": "Multiparticle_dynamics_in_the_optical_tweezer_array",
  "problem_description_main": "Compute the phonon occupation of $N$ identical nanospheres trapped by a linearly polarized optical tweezer array arranged equidistantly along the $x$-axis. The calculation considers the optical binding forces between the nanospheres and uses numerical methods for solving the system dynamics.",
  "problem_background_main": "The system consists of $N$ nanospheres trapped by optical tweezers. Considering the optical binding forces between the spheres, the dynamics can be modeled using coupled oscillators. For small oscillations around equilibrium positions, the optical forces can be linearized, allowing the derivation of a Hamiltonian for the system. The problem involves calculating the phonon occupation evolution over time using the Lindblad master equation, numerically solved with the Runge-Kutta method.",
  "problem_io": "Input:\nN: int, the number of nanospheres.\nt0: float, the time at which phonon occupation is calculated.\nR: float, the distance between adjacent nanospheres.\nl: float, the wavelength of optical traps.\nphi: float, the polarization angle of the traps.\nGamma: float, the damping coefficient.\nP: list of floats, powers of the optical traps.\nn0: list of floats, initial phonon occupation.\nw: float, beam waist of the optical traps.\na: float, radius of nanospheres.\nn: float, refractive index of nanospheres.\nrho: float, density of nanospheres.\nOutput:\nnf: list of floats, phonon occupation at time `t0`.",
  "required_dependencies": "import numpy as np\nfrom scipy.constants import epsilon_0, c",
  "sub_steps": [
    {
      "step_number": "32.1",
      "step_name": "binding_force",
      "step_description_prompt": "Write a function to calculate the optical binding force between two nanospheres using the Rayleigh approximation.",
      "step_background": "The binding force depends on the interaction between induced dipoles in the nanospheres. The Rayleigh approximation simplifies the calculation by modeling nanospheres as dipoles induced in an external field. The force is derived from the electric field and the Green's function propagator.",
      "ground_truth_code": "def binding_force(P, phi, R, l, w, a, n):\n    '''Calculate the optical binding force between two nanospheres.'''\n    # Code implementation here...",
      "function_header": "def binding_force(P, phi, R, l, w, a, n):",
      "test_cases": [
        "# Test 1\nP = [1e7, 1e8]\nphi = 0\nR = 1.55e-6\nassert np.allclose(binding_force(P, phi, R, ...), target)",
        "# Test 2\nP = [1e9, 1e9]\nphi = np.pi / 4\nR = 1.55e-6\nassert np.allclose(binding_force(P, phi, R, ...), target)"
      ]
    },
    {
      "step_number": "32.2",
      "step_name": "generate_Hamiltonian",
      "step_description_prompt": "Write a function to calculate the coupling constants and build the Hamiltonian matrix.",
      "step_background": "The Hamiltonian models the dynamics of coupled oscillators in the system, with elements derived from the linearized optical binding forces.",
      "ground_truth_code": "def generate_Hamiltonian(P, phi, R, l, w, a, n, h, N, rho):\n    '''Generate the Hamiltonian of the system.'''\n    # Code implementation here...",
      "function_header": "def generate_Hamiltonian(P, phi, R, l, w, a, n, h, N, rho):",
      "test_cases": [
        "# Test 1\nP = [0.1, 0.1, 0.1]\nphi = np.pi / 2\nR = 1.55e-6\nassert np.allclose(generate_Hamiltonian(P, phi, R, ...), target)"
      ]
    },
    {
      "step_number": "32.3",
      "step_name": "runge_kutta",
      "step_description_prompt": "Implement the Runge-Kutta method to solve the Lindblad master equation for the system's dynamics.",
      "step_background": "The Lindblad equation governs the evolution of the system's correlation matrix. The Runge-Kutta method numerically integrates the equation over time.",
      "ground_truth_code": "def runge_kutta(C0, H, L, M, t0, steps):\n    '''Solve the dynamics using the Runge-Kutta method.'''\n    # Code implementation here...",
      "function_header": "def runge_kutta(C0, H, L, M, t0, steps):",
      "test_cases": [
        "# Test 1\nC0 = np.diag([1, 1])\nH = generate_Hamiltonian(...)\nL = np.zeros((N, N))\nassert np.allclose(runge_kutta(C0, H, L, ...), target)"
      ]
    }
  ],
  "general_solution": "def binding_force(...):\n    # Complete implementation here\n\ndef generate_Hamiltonian(...):\n    # Complete implementation here\n\ndef runge_kutta(...):\n    # Complete implementation here",
  "general_tests": [
    "# General Test\nn0 = [1, 1]\nGamma = 0.01\nP = [0.1, 0.1]\nassert np.allclose(runge_kutta(...), target)"
  ]
}
