{
    "problem_name": "Multiparticle_dynamics_in_the_optical_tweezer_array",
    "problem_id": "32",
    "problem_description_main": "A system of $N$ identical nanospheres is trapped by an optical tweezer array that is arranged equidistantly along the $x$ axis. Each nanosphare is confined to oscillate near its equillibrium position because of the harmonic trapping forces from the linearly polarized optical tweezer array. The adjacent nanosphares interact via optical binding forces resulting from induced dipoles. Compute the dynamics of phonon occupation for small oscillations along the $x$-axis near the equilibrium positions of each sphere.",
    "problem_background_main": "In an optical tweezer array, trapped nanospheres experience optical binding forces due to interactions between their induced dipoles and external fields. These forces, combined with damping and vibrational couplings, govern the dynamics of phonon occupation. This problem explores these dynamics by modeling the system as coupled harmonic oscillators.",
    "problem_io": "'''\nInput:\nN : int\n Number of trapped nanospheres.\nt0 : float\n   Time point to compute phonon occupation.\nR : float\n    Distance between adjacent nanospheres.\nl : float\n    Wavelength of optical traps.\nphi : float\n    Polarization angle of the traps.\nGamma : float\n    Damping coefficient of nanospheres.\nP : list of floats\n    Power of optical traps for each nanosphere.\nn0 : list of floats\n    Initial phonon occupation numbers.\nw : float\n    Beam waist of optical traps.\na : float\n    Radius of nanospheres.\nn : float\n    Refractive index of nanospheres.\nrho : float\n    Density of nanospheres.\n\nOutput:\nnf : list of floats\n    Phonon occupation numbers at time t0.\n'''",
    "required_dependencies": "import numpy as np\nimport scipy\nfrom scipy.constants import epsilon_0, c", 
    "sub_steps": [
        {
            "step_number": "32.1",
            "step_name": "Calculate Optical Binding Force",
            "step_description_prompt": " Two linearly polarized optical traps having the same polarization direction are separated by a distance $R$. Implement a python function to compute the optical binding force between the two identical nanospheres trapped by a linearly polarized optical tweezer array. The function should calculate the induced dipole interactions between the two nanosphares, assuming the Rayleigh approximation.",
            "step_background": "The Rayleigh approximation can be considered to solve this problem as here each nanosphere funtions as an induced dipole in the external field. The optical binding force arises from the interaction between the dipole induced in one nanosphere and the electric field generated by the induced dipole of the other nanosphere. This force is derived from the dyadic Green's function and depends on factors like polarization, inter-sphere distance (R), and beam parameters.",
            "function_header": "def calculate_binding_force(P, phi, R, l, w, a, n):\n    '''\n    Calculate optical binding force between two nanospheres.\n    Input:\n    P : list of floats\n        Power of two optical traps.\n    phi : float\n        Polarization direction of traps.\n    R : float\n        Distance between nanospheres.\n    l : float\n        Wavelength of traps.\n    w : float\n        Beam waist.\n    a : float\n        Radius of nanospheres.\n    n : float\n        Refractive index of nanospheres.\n\n    Output:\n    F : float\n        Optical binding force along the x-axis.\n    '''",
            "ground_truth_code": "def calculate_binding_force(P, phi, R, l, w, a, n):\n    alpha = 4 * np.pi * epsilon_0 * a**3 * (n**2 - 1) / (n**2 + 2)\n    k = 2 * np.pi / l\n    E1 = np.sqrt(4 * P[0] / (np.pi * w**2 * epsilon_0 * c))\n    E2 = np.sqrt(4 * P[1] / (np.pi * w**2 * epsilon_0 * c))\n    F = (alpha**2 * E1 * E2 / (8 * np.pi * epsilon_0 * R**4)) * (\n        -3 * np.cos(k * R) - 3 * k * R * np.sin(k * R) + (k * R)**2 * np.cos(k * R))\n    return F",
            "test_cases": [
                "assert np.isclose(calculate_binding_force([1e-3, 1e-3], 0, 1.5e-6, 1.55e-6, 0.6e-6, 0.1e-6, 1.444), target)",
                "assert np.isclose(calculate_binding_force([1e-3, 2e-3], np.pi/4, 1e-6, 1.55e-6, 0.6e-6, 0.1e-6, 1.444), target)"
            ]
        },
        {
            "step_number": "32.2",
            "step_name": "Generate Hamiltonian",
            "step_description_prompt": "Taking into account the linearized optical binding forces, write a function to compute the Hamiltonian of the provided nanosphere system.",
            "step_background": "The Hamiltonian represents the coupled oscillatory system, incorporating resonant frequencies and coupling constants between nanospheres. These parameters are derived from linearized binding forces.",
            "function_header": "def generate_hamiltonian(P, phi, R, l, w, a, n, N, rho):\n    '''\n    Generate Hamiltonian for nanosphere system.\n    Input:\n    P : list of floats\n        Trap powers.\n    phi : float\n        Polarization angle.\n    R : float\n        Inter-sphere distance.\n    l : float\n        Wavelength.\n    w : float\n        Beam waist.\n    a : float\n        Sphere radius.\n    n : float\n        Refractive index.\n    N : int\n        Number of nanospheres.\n    rho : float\n        Sphere density.\n\n    Output:\n    H : np.ndarray\n        Hamiltonian matrix of shape (N, N).\n    '''",
            "ground_truth_code": "def generate_hamiltonian(P, phi, R, l, w, a, n, N, rho):\n    H = np.zeros((N, N))\n    m = (4/3) * np.pi * a**3 * rho\n    for i in range(N):\n        H[i, i] = np.sqrt(binding_force(P[i], phi, R, l, w, a, n) / m)\n        if i > 0:\n            coupling = calculate_binding_force(P[i - 1:i + 1], phi, R, l, w, a, n)\n            H[i, i - 1] = H[i - 1, i] = -coupling / m\n    return H",
            "test_cases": [
                "assert np.allclose(generate_hamiltonian([...]), target)",
                "assert np.allclose(generate_hamiltonian([...]), target)"
            ]
        },
        {
            "step_number": "32.3",
            "step_name": "Runge-Kutta for Phonon Dynamics",
            "step_description_prompt": "Implement the fourth-order Runge-Kutta method to simulate phonon occupation dynamics in the Lindblad form within the nanosphare system.",
            "step_background": "The Lindblad master equation describes the evolution of the correlation matrix under dissipation and external fields. The RK4 method numerically integrates this equation.",
            "function_header": "def runge_kutta_dynamics(C0, H, L, M, t0, steps):\n    '''\n    Simulate phonon occupation dynamics using RK4 method.\n    Input:\n    C0 : np.ndarray\n        Initial correlation matrix.\n    H : np.ndarray\n        System Hamiltonian.\n    L : np.ndarray\n        Dissipation matrix.\n    M : np.ndarray\n        Reservoir matrix.\n    t0 : float\n        Time point for evaluation.\n    steps : int\n        Number of integration steps.\n\n    Output:\n    nf : list of floats\n        Phonon occupations at time t0.\n    '''",
            "ground_truth_code": "def runge_kutta_dynamics(C0, H, L, M, t0, steps):\n    dt = t0 / steps\n    C = C0\n    for _ in range(steps):\n        k1 = dt * (1j * (H @ C - C @ H) + L @ C + M)\n        k2 = dt * (1j * (H @ (C + 0.5 * k1) - (C + 0.5 * k1) @ H) + L @ (C + 0.5 * k1) + M)\n        k3 = dt * (1j * (H @ (C + 0.5 * k2) - (C + 0.5 * k2) @ H) + L @ (C + 0.5 * k2) + M)\n        k4 = dt * (1j * (H @ (C + k3) - (C + k3) @ H) + L @ (C + k3) + M)\n        C += (k1 + 2 * k2 + 2 * k3 + k4) / 6\n    return np.diagonal(C)",
            "test_cases": [
                "assert np.isclose(runge_kutta_dynamics([...]), target)",
                "assert np.isclose(runge_kutta_dynamics([...]), target)"
            ]
        }
    ],
    "general_tests": [
        "assert np.allclose(simulate_phonon_dynamics([...]), target)"
    ]
}

# _comment
{
  "summary_of_changes": [
    {
      "change_number": 1,
      "description": "Main problem statement in line 4 was not clear. It has been modified to make it more clear, high-level, and unambiguous."
    },
    {
      "change_number": 2,
      "description": "The statement of subproblem 32.1 and 32.2 have been modified for clarity."
    },
    {
      "change_number": 3,
      "description": "Background statement of subproblem 32.1 has also been slightly updated for clarity."
    },
    {
      "change_number": 4,
      "description": "Statement for subproblem 32.3 has been slightly modified."
    }
  ]
}



