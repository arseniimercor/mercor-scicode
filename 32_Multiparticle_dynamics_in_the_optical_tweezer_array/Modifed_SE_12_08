{
    "problem_name": "Multiparticle_dynamics_in_the_optical_tweezer_array",
    "problem_id": "32",
    "problem_description_main": "A system of $N$ identical nanospheres is trapped by an optical tweezer array that is arranged equidistantly along the $x$ axis. Each nanosphere is confined to oscillate near its equilibrium position because of the harmonic trapping forces from the linearly polarized optical tweezer array. The adjacent nanospheres interact via optical binding forces resulting from induced dipoles. Simulate the dynamics of phonon occupation using Python functionalities for small oscillations along the $x$-axis near the equilibrium positions of each sphere.",
    "problem_background_main": "In an optical tweezer array, trapped nanospheres experience optical binding forces due to interactions between their induced dipoles and external fields. These forces, combined with damping and vibrational couplings, govern the dynamics of phonon occupation. This problem explores these dynamics by modeling the system as coupled harmonic oscillators.",
    "problem_io": "'''\nInput:\nN : int\n    Number of trapped nanospheres.\nt0 : float\n    Time point to compute phonon occupation.\nR : float\n    Distance between adjacent nanospheres.\nl : float\n    Wavelength of optical traps.\nphi : float\n    Polarization angle of the traps.\nGamma : float\n    Damping coefficient of nanospheres.\nP : list of floats\n    Power of optical traps for each nanosphere.\nn0 : list of floats\n    Initial phonon occupation numbers.\nw : float\n    Beam waist of optical traps.\na : float\n    Radius of nanospheres.\nn : float\n    Refractive index of nanospheres.\nrho : float\n    Density of nanospheres.\n\nOutput:\nnf : list of floats\n    Phonon occupation numbers at time t0.\n'''",
    "required_dependencies": "import numpy as np\nimport scipy\nfrom scipy.constants import epsilon_0, c",
    "sub_steps": [
        {
            "step_number": "32.1",
            "step_name": "Calculate Optical Binding Force",
            "step_description_prompt": "Two linearly polarized optical traps having the same polarization direction are separated by a distance $R$. Implement a Python function to compute the optical binding force between the two identical nanospheres trapped by a linearly polarized optical tweezer array. The function should calculate the induced dipole interactions between the two nanospheres, assuming the Rayleigh approximation.",
            "step_background": "The derived radial optical binding force $F_x$ can be expressed as $F_x = F_{xx} + F_{xy}$, where:\n\n$$F_{xx} = \\frac{2 \\alpha^2 E_1 E_2 \\cos^2(\\varphi)}{8\\pi \\epsilon_0 R^4} \\left[ -3 \\cos(kR) - 3kR \\sin(kR) + (kR)^2 \\cos(kR) \\right],$$\n\nand\n\n$$F_{xy} = \\frac{\\alpha^2 E_1 E_2 \\sin^2(\\varphi)}{8\\pi \\epsilon_0 R^4} \\left[ 3 \\cos(kR) + 3kR \\sin(kR) - 2(kR)^2 \\cos(kR) - (kR)^3 \\sin(kR) \\right].$$\n\nHere, $\\varphi$ is the angle between the polarization direction of the array and the $x$-axis. The Rayleigh approximation assumes each nanosphere behaves as an induced dipole in the external field.",
            "function_header": "def calculate_binding_force(P, phi, R, l, w, a, n):",
            "ground_truth_code": "def calculate_binding_force(P, phi, R, l, w, a, n):\n    '''\n    Function to calculate the optical binding force between two trapped nanospheres.\n\n    Parameters\n    ----------\n    P : list of floats\n        Power of the two optical traps.\n    phi : float\n        Polarization direction of the optical traps (radians).\n    R : float\n        Distance between the trapped nanospheres (meters).\n    l : float\n        Wavelength of the optical traps (meters).\n    w : float\n        Beam waist of the optical traps (meters).\n    a : float\n        Radius of the trapped nanospheres (meters).\n    n : float\n        Refractive index of the trapped nanospheres.\n\n    Returns\n    -------\n    F : float\n        The optical binding force between two trapped nanospheres (N).\n    '''\n    import numpy as np\n    from scipy.constants import epsilon_0, c\n\n    # Wave number\n    k = 2 * np.pi / l\n\n    # Scalar polarizability\n    alpha = (4 * np.pi * epsilon_0 * a**3 * (n**2 - 1)) / (n**2 + 2)\n\n    # Electric field of the optical traps\n    E1 = np.sqrt(4 * P[0] / (np.pi * w**2 * epsilon_0 * c))\n    E2 = np.sqrt(4 * P[1] / (np.pi * w**2 * epsilon_0 * c))\n\n    # Fx calculation\n    Fxx = (\n        2 * alpha**2 * E1 * E2 * np.cos(phi)**2 / (8 * np.pi * epsilon_0 * R**4)\n        * (-3 * np.cos(k * R) - 3 * k * R * np.sin(k * R) + (k * R)**2 * np.cos(k * R))\n    )\n    Fxy = (\n        alpha**2 * E1 * E2 * np.sin(phi)**2 / (8 * np.pi * epsilon_0 * R**4)\n        * (3 * np.cos(k * R) + 3 * k * R * np.sin(k * R) - 2 * (k * R)**2 * np.cos(k * R) - (k * R)**3 * np.sin(k * R))\n    )\n\n    # Total force\n    F = Fxx + Fxy\n\n    return F",
            "test_cases": [
                {
                    "P": [10000000, 100000000],
                    "phi": 0,
                    "R": 1.55e-6,
                    "l": 1.55e-6,
                    "w": 600e-9,
                    "a": 100e-9,
                    "n": 1.444,
                    "expected": 2.090553478330249e-06
                },
                {
                    "P": [10e6, 100e6],
                    "phi": 1.5708,
                    "R": 1.55e-6,
                    "l": 1.55e-6,
                    "w": 600e-9,
                    "a": 100e-9,
                    "n": 1.444,
                    "expected": -2.17651746535146e-06
                },
                {
                    "P": [1e9, 1e9],
                    "phi": 0.7854,
                    "R": 1.55e-6,
                    "l": 1.55e-6,
                    "w": 600e-9,
                    "a": 100e-9,
                    "n": 1.444,
                    "expected": -1.3592099786808985e-06
                }
            ],
            "return_line": "return F"
        }
    ]
}




