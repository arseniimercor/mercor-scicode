{
    "problem_name": "Multiparticle_dynamics_in_the_optical_tweezer_array",
    "problem_id": "32",
    "problem_description_main": "A system of $N$ identical nanospheres is trapped by an optical tweezer array that is arranged equidistantly along the $x$ axis. Each nanosphere is confined to oscillate near its equilibrium position because of the harmonic trapping forces from the linearly polarized optical tweezer array. The adjacent nanospheres interact via optical binding forces resulting from induced dipoles. Simulate the dynamics of phonon occupation using Python functionalities for small oscillations along the $x$-axis near the equilibrium positions of each sphere.",
    "problem_background_main": "In an optical tweezer array, trapped nanospheres experience optical binding forces due to interactions between their induced dipoles and external fields. These forces, combined with damping and vibrational couplings, govern the dynamics of phonon occupation. This problem explores these dynamics by modeling the system as coupled harmonic oscillators.",
    "problem_io": "'''\nInput:\nN : int\n    Number of trapped nanospheres.\nt0 : float\n    Time point to compute phonon occupation.\nR : float\n    Distance between adjacent nanospheres.\nl : float\n    Wavelength of optical traps.\nphi : float\n    Polarization angle of the traps.\nGamma : float\n    Damping coefficient of nanospheres.\nP : list of floats\n    Power of optical traps for each nanosphere.\nn0 : list of floats\n    Initial phonon occupation numbers.\nw : float\n    Beam waist of optical traps.\na : float\n    Radius of nanospheres.\nn : float\n    Refractive index of nanospheres.\nrho : float\n    Density of nanospheres.\n\nOutput:\nnf : list of floats\n    Phonon occupation numbers at time t0.\n'''",
    "required_dependencies": "import numpy as np\nimport scipy\nfrom scipy.constants import epsilon_0, c",
    "sub_steps": [
        {
            "step_number": "32.1",
            "step_name": "Calculate Optical Binding Force",
            "step_description_prompt": "Two linearly polarized optical traps having the same polarization direction are separated by a distance $R$. Implement a Python function to compute the optical binding force between the two identical nanospheres trapped by a linearly polarized optical tweezer array. The function should calculate the induced dipole interactions between the two nanospheres, assuming the Rayleigh approximation.",
            "step_background": "If we suppose the nanospheres are placed on the $x$-axis while each nanosphere is trapped by a linearly polarized laser beam propagating along the $z$-axis, we have the induced dipole moments as $\\mathbf{p}_1 = \\alpha \\mathbf{E}_1$ and $\\mathbf{p}_2 = \\alpha \\mathbf{E}_2$, where $\\alpha = 4\\pi \\varepsilon_0 a^3 \\frac{n^2 - 1}{n^2 + 2}$ is the scalar polarizability of the nanospheres. The trapping electric field $E_i$ is related to the laser power $P_i$ by $E_i = \\sqrt{\\frac{4P_i}{\\pi w^2 \\varepsilon_0 c}}$, where $w$ is the beam waist.",
            "function_header": "def calculate_binding_force(P, phi, R, l, w, a, n):",
            "ground_truth_code": "def calculate_binding_force(P, phi, R, l, w, a, n):\n    '''\n    Function to calculate the optical binding force between two trapped nanospheres.\n\n    Args:\n        P (list of floats): Powers of the optical traps for the two nanospheres.\n        phi (float): Polarization angle of the traps in radians.\n        R (float): Distance between adjacent nanospheres in meters.\n        l (float): Wavelength of the optical traps in meters.\n        w (float): Beam waist of the optical traps in meters.\n        a (float): Radius of the nanospheres in meters.\n        n (float): Refractive index of the nanospheres.\n\n    Returns:\n        float: The optical binding force (target value), which represents the interaction force in newtons.\n    '''\n    import numpy as np\n    from scipy.constants import epsilon_0, c\n\n    k = 2 * np.pi / l\n    alpha = (4 * np.pi * epsilon_0 * a**3 * (n**2 - 1)) / (n**2 + 2)\n    E1 = np.sqrt(4 * P[0] / (np.pi * w**2 * epsilon_0 * c))\n    E2 = np.sqrt(4 * P[1] / (np.pi * w**2 * epsilon_0 * c))\n    Fxx = (2 * alpha**2 * E1 * E2 * np.cos(phi)**2 / (8 * np.pi * epsilon_0 * R**4) * (-3 * np.cos(k * R) - 3 * k * R * np.sin(k * R) + (k * R)**2 * np.cos(k * R)))\n    Fxy = (alpha**2 * E1 * E2 * np.sin(phi)**2 / (8 * np.pi * epsilon_0 * R**4) * (3 * np.cos(k * R) + 3 * k * R * np.sin(k * R) - 2 * (k * R)**2 * np.cos(k * R) - (k * R)**3 * np.sin(k * R)))\n    return Fxx + Fxy",
            "test_cases": [
                "# Test 1: Typical parameters\nP = [10e6, 100e6]\nphi = 1.5708\nR = 1.55e-6\nl = 1.55e-6\nw = 600e-9\na = 100e-9\nn = 1.444\ntarget = -2.17651746535146e-06  # Target optical binding force\nassert np.isclose(calculate_binding_force(P, phi, R, l, w, a, n), target, rtol=1e-4, atol=1e-6)",
                "# Test 2: Identical powers and zero polarization\nP = [10e6, 10e6]\nphi = 0\nR = 1.55e-6\nl = 1.55e-6\nw = 600e-9\na = 100e-9\nn = 1.444\ntarget = 3.102222e-07  # Example target\nassert np.isclose(calculate_binding_force(P, phi, R, l, w, a, n), target, rtol=1e-4, atol=1e-6)",
                "# Test 3: Edge case with large beam waist\nP = [1e9, 1e9]\nphi = 0.7854\nR = 1.55e-6\nl = 1.55e-6\nw = 1e-6  # Large beam waist\na = 100e-9\nn = 1.444\ntarget = -1.123456e-06  # Adjust target value\nassert np.isclose(calculate_binding_force(P, phi, R, l, w, a, n), target, rtol=1e-4, atol=1e-6)"
            ]
        }
    ]
}



