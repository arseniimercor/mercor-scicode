{
    "problem_name": "Multiparticle_dynamics_in_the_optical_tweezer_array",
    "problem_id": "32",
    "problem_description_main": "A system of $N$ identical nanospheres is trapped by an optical tweezer array that is arranged equidistantly along the $x$ axis. Each nanosphere is confined to oscillate near its equilibrium position because of the harmonic trapping forces from the linearly polarized optical tweezer array. The adjacent nanospheres interact via optical binding forces resulting from induced dipoles. Simulate the dynamics of phonon occupation using Python functionalities for small oscillations along the $x$-axis near the equilibrium positions of each sphere.",
    "problem_background_main": "In an optical tweezer array, trapped nanospheres experience optical binding forces due to interactions between their induced dipoles and external fields. These forces, combined with damping and vibrational couplings, govern the dynamics of phonon occupation. This problem explores these dynamics by modeling the system as coupled harmonic oscillators.",
    "problem_io": "'''\nInput:\nN : int\n    Number of trapped nanospheres.\nt0 : float\n    Time point to compute phonon occupation.\nR : float\n    Distance between adjacent nanospheres.\nl : float\n    Wavelength of optical traps.\nphi : float\n    Polarization angle of the traps.\nGamma : float\n    Damping coefficient of nanospheres.\nP : list of floats\n    Power of optical traps for each nanosphere.\nn0 : list of floats\n    Initial phonon occupation numbers.\nw : float\n    Beam waist of optical traps.\na : float\n    Radius of nanospheres.\nn : float\n    Refractive index of nanospheres.\nrho : float\n    Density of nanospheres.\n\nOutput:\nnf : list of floats\n    Phonon occupation numbers at time t0.\n'''",
    "required_dependencies": "import numpy as np\nimport scipy\nfrom scipy.constants import epsilon_0, c",
    "sub_steps": [
        {
            "step_number": "32.1",
            "step_name": "Calculate Optical Binding Force",
            "step_description_prompt": "Two linearly polarized optical traps having the same polarization direction are separated by a distance $R$. Implement a Python function to compute the optical binding force between the two identical nanospheres trapped by a linearly polarized optical tweezer array. The function should calculate the induced dipole interactions between the two nanospheres, assuming the Rayleigh approximation.",
            "step_background": "The Rayleigh approximation assumes that each nanosphere acts as an induced dipole in the external field. The optical binding force arises from the interaction between the dipole induced in one nanosphere and the electric field generated by the induced dipole of the other nanosphere. This force depends on factors such as polarization, inter-sphere distance $R$, and beam parameters.",
            "function_header": "def calculate_binding_force(P, phi, R, l, w, a, n):",
            "ground_truth_code": "def calculate_binding_force(P, phi, R, l, w, a, n):\n    import numpy as np\n    from scipy.constants import epsilon_0, c\n    k = 2 * np.pi / l\n    alpha = (4 * np.pi * epsilon_0 * a**3 * (n**2 - 1)) / (n**2 + 2)\n    E1 = np.sqrt(4 * P[0] / (np.pi * w**2 * epsilon_0 * c))\n    E2 = np.sqrt(4 * P[1] / (np.pi * w**2 * epsilon_0 * c))\n    Fxx = (2 * alpha**2 * E1 * E2 * np.cos(phi)**2 / (8 * np.pi * epsilon_0 * R**4) * (-3 * np.cos(k * R) - 3 * k * R * np.sin(k * R) + (k * R)**2 * np.cos(k * R)))\n    Fxy = (alpha**2 * E1 * E2 * np.sin(phi)**2 / (8 * np.pi * epsilon_0 * R**4) * (3 * np.cos(k * R) + 3 * k * R * np.sin(k * R) - 2 * (k * R)**2 * np.cos(k * R) - (k * R)**3 * np.sin(k * R)))\n    return Fxx + Fxy",
            "test_cases": [
                {
                    "description": "Aligned polarization",
                    "input": {
                        "P": [10000000, 100000000],
                        "phi": 0,
                        "R": 1.55e-6,
                        "l": 1.55e-6,
                        "w": 600e-9,
                        "a": 100e-9,
                        "n": 1.444
                    },
                    "target": 2.090553478330249e-06
                },
                {
                    "description": "Perpendicular polarization",
                    "input": {
                        "P": [10e6, 100e6],
                        "phi": 1.5708,
                        "R": 1.55e-6,
                        "l": 1.55e-6,
                        "w": 600e-9,
                        "a": 100e-9,
                        "n": 1.444
                    },
                    "target": -2.17651746535146e-06
                },
                {
                    "description": "Mixed polarization",
                    "input": {
                        "P": [1e9, 1e9],
                        "phi": 0.7854,
                        "R": 1.55e-6,
                        "l": 1.55e-6,
                        "w": 600e-9,
                        "a": 100e-9,
                        "n": 1.444
                    },
                    "target": -1.3592099786808985e-06
                }
            ],
            "return_line": "return Fxx + Fxy"
        },
        {
            "step_number": "32.2",
            "step_name": "Generate Hamiltonian",
            "step_description_prompt": "Develop a Python function to compute the Hamiltonian for the provided nanospherical system, taking into account the linearized optical binding force acting upon the trapped nanospheres.",
            "step_background": "The Hamiltonian matrix incorporates resonant frequencies and coupling constants between nanospheres, derived from linearized optical binding forces.",
            "function_header": "def generate_hamiltonian(P, phi, R, l, w, a, n, N, rho):",
            "ground_truth_code": "def generate_hamiltonian(P, phi, R, l, w, a, n, N, rho):\n    import numpy as np\n    m = (4 / 3) * np.pi * a**3 * rho\n    H = np.zeros((N, N))\n    for i in range(N):\n        H[i, i] = np.sqrt(calculate_binding_force([P[i], P[i]], phi, R, l, w, a, n) / m)\n        if i > 0:\n            coupling = calculate_binding_force([P[i - 1], P[i]], phi, R, l, w, a, n)\n            H[i, i - 1] = H[i - 1, i] = -coupling / (2 * m * np.sqrt(H[i, i] * H[i - 1, i - 1]))\n    return H",
            "test_cases": [
                {
                    "description": "Five spheres aligned polarization",
                    "input": {
                        "P": [100e-3] * 5,
                        "phi": 1.5708,
                        "R": 0.99593306197 * 1550e-9,
                        "l": 1550e-9,
                        "w": 600e-9,
                        "a": 100e-9,
                        "n": 1.444,
                        "N": 5,
                        "rho": 2.648e3
                    },
                    "target": "Hamiltonian matrix matching theoretical calculation"
                },
                {
                    "description": "Five spheres perpendicular polarization",
                    "input": {
                        "P": [100e-3] * 5,
                        "phi": 1.5708,
                        "R": 2 * 1550e-9,
                        "l": 1550e-9,
                        "w": 600e-9,
                        "a": 100e-9,
                        "n": 1.444,
                        "N": 5,
                        "rho": 2.648e3
                    },
                    "target": "Hamiltonian matrix matching theoretical calculation"
                }
            ],
            "return_line": "return H"
        }
    ]
}
