{
    "problem_name": "Multiparticle_dynamics_in_the_optical_tweezer_array",
    "problem_id": "32",
    "problem_description_main": "A system of $N$ identical nanospheres is trapped by an optical tweezer array that is arranged equidistantly along the $x$ axis. Each nanosphere is confined to oscillate near its equilibrium position because of the harmonic trapping forces from the linearly polarized optical tweezer array. The adjacent nanospheres interact via optical binding forces resulting from induced dipoles. Simulate the dynamics of phonon occupation using Python functionalities for small oscillations along the $x$-axis near the equilibrium positions of each sphere.",
    "problem_background_main": "In an optical tweezer array, trapped nanospheres experience optical binding forces due to interactions between their induced dipoles and external fields. These forces, combined with damping and vibrational couplings, govern the dynamics of phonon occupation. This problem explores these dynamics by modeling the system as coupled harmonic oscillators.",
    "required_dependencies": "import numpy as np\nfrom scipy.constants import epsilon_0, c",
    "problem_io":   "def solve_multiparticle_dynamics(N, t0, R, l, phi, Gamma, P, n0, w, a, n, h, rho, steps) -> list:\n    \"\"\"\n    Simulates phonon occupation dynamics in an optical tweezer array.\n\n    Args:\n        N (int): Number of nanospheres.\n        t0 (float): Time for simulation (seconds).\n        R (float): Distance between adjacent nanospheres (meters).\n        l (float): Wavelength of optical tweezers (meters).\n        phi (float): Polarization angle (radians).\n        Gamma (list): Damping coefficients for each nanosphere.\n        P (list): Powers of optical tweezers (Watts).\n        n0 (list): Initial phonon occupation numbers.\n        w (float): Beam waist of optical tweezers (meters).\n        a (float): Radius of nanospheres (meters).\n        n (float): Refractive index of the nanospheres.\n        h (float): Step size for numerical derivative (meters)\n        rho (float): Density of nanospheres (kg/m\u00b3).\n        steps (int): Number of RK4 time steps.\n\n    Returns:\n        list: Phonon occupation numbers at time t0.\n    \"\"\"",
    "sub_steps": [
        {
            "step_number": "32.1",
            "step_name": "Calculate Optical Binding Force",
            "step_description_prompt": "Two linearly polarized optical traps having the same polarization direction are separated by a distance $R$. Implement a Python function to compute the optical binding force between the two identical nanospheres trapped by a linearly polarized optical tweezer array. The function should calculate the induced dipole interactions between the two nanospheres, assuming the Rayleigh approximation.",
            "step_background": "If we suppose the nanospheres are placed on the $x$-axis while each nanosphere is trapped by a linearly polarized laser beam propagating along the $z$-axis, we have the induced dipole moments as $\\mathbf{p}_1 = \\alpha \\mathbf{E}_1$ and $\\mathbf{p}_2 = \\alpha \\mathbf{E}_2$, where $\\alpha = 4\\pi \\varepsilon_0 a^3 \\frac{n^2 - 1}{n^2 + 2}$ is the scalar polarizability of the nanospheres. The trapping electric field $E_i$ is related to the laser power $P_i$ by $E_i = \\sqrt{\\frac{4P_i}{\\pi w^2 \\varepsilon_0 c}}$, where $w$ is the beam waist. The electric field emitted by dipole 2 at the location of dipole 1 can be written as $\\mathbf{E}_{\\mathrm{ind},2}(\\mathbf{r}_1) = G(\\mathbf{R}) \\mathbf{p}_2$, where $G_{pq}$ is the dyadic Green's function, which is expressed as:\n\n$$G_{pq} = \\frac{\\exp(ikR)}{4\\pi \\varepsilon_0 R^3} \\left[ \\left(3 - 3ikR - k^2R^2\\right) \\frac{R_p R_q}{R^2} + \\left(k^2R^2 + ikR - 1\\right) \\delta_{pq} \\right].$$\n\nThe optical binding force along the $x$-axis is derived as:\n\n$$F_x = \\frac{1}{2} \\operatorname{Re} \\left[ \\mathbf{p}_1 \\cdot \\nabla_x (\\mathbf{E}_{\\mathrm{ind},2}(\\mathbf{r}_1)) \\right].$$\n\nThe derived radial optical binding force $F_x$ can be expressed as:\n\n$$F_x = F_{xx} + F_{xy},$$\n\nwhere:\n\n$$F_{xx} = \\frac{2 \\alpha^2 E_{x1} E_{x2}}{8\\pi \\varepsilon_0 R^4} \\left[ -3 \\cos(kR) - 3kR \\sin(kR) + (kR)^2 \\cos(kR) \\right],$$\n\nand\n\n$$F_{xy} = \\frac{\\alpha^2 E_{y1} E_{y2}}{8\\pi \\varepsilon_0 R^4} \\left[ 3 \\cos(kR) + 3kR \\sin(kR) - 2(kR)^2 \\cos(kR) - (kR)^3 \\sin(kR) \\right].$$\n\nThe Rayleigh approximation assumes that each nanosphere acts as an induced dipole in the external field. The optical binding force arises from the interaction between the dipole induced in one nanosphere and the electric field generated by the induced dipole of the other nanosphere. This force depends on factors such as polarization, inter-sphere distance $R$, and beam parameters.",
            "function_header": "def calculate_binding_force(P, phi, R, l, w, a, n) -> float:\n    \"\"\"\n    Function to calculate the optical binding force between two trapped nanospheres.\n\n    Args:\n        P (list of float): Laser powers for the two nanospheres (Watts).\n        phi (float): Polarization angle of the tweezers (radians).\n        R (float): Distance between adjacent nanospheres (meters).\n        l (float): Wavelength of the optical tweezers (meters).\n        w (float): Beam waist of the optical tweezers (meters).\n        a (float): Radius of the nanospheres (meters).\n        n (float): Refractive index of the nanospheres.\n\n    Returns:\n        float: Optical binding force (Newtons).\n    \"\"\"",
            "ground_truth_code": "def calculate_binding_force(P, phi, R, l, w, a, n) -> float:\n    \"\"\"\n    Function to calculate the optical binding force between two trapped nanospheres.\n\n    Args:\n        P (list of float): Laser powers for the two nanospheres (Watts).\n        phi (float): Polarization angle of the tweezers (radians).\n        R (float): Distance between adjacent nanospheres (meters).\n        l (float): Wavelength of the optical tweezers (meters).\n        w (float): Beam waist of the optical tweezers (meters).\n        a (float): Radius of the nanospheres (meters).\n        n (float): Refractive index of the nanospheres.\n\n    Returns:\n        float: Optical binding force (Newtons).\n    \"\"\"\n\n    # Wave number\n    k = 2 * np.pi / l\n    # Scalar polarizability\n    alpha = (4 * np.pi * epsilon_0 * a**3 * (n**2 - 1)) / (n**2 + 2)\n    # Electric fields\n    E1 = np.sqrt(4 * P[0] / (np.pi * w**2 * epsilon_0 * c))\n    E2 = np.sqrt(4 * P[1] / (np.pi * w**2 * epsilon_0 * c))\n    # Forces\n    Fxx = (\n        2 * alpha**2 * E1 * E2 * np.cos(phi)**2 / (8 * np.pi * epsilon_0 * R**4)\n        * (-3 * np.cos(k * R) - 3 * k * R * np.sin(k * R) + (k * R)**2 * np.cos(k * R))\n    )\n    Fxy = (\n        alpha**2 * E1 * E2 * np.sin(phi)**2 / (8 * np.pi * epsilon_0 * R**4)\n        * (3 * np.cos(k * R) + 3 * k * R * np.sin(k * R) - 2 * (k * R)**2 * np.cos(k * R) - (k * R)**3 * np.sin(k * R))\n    )\n    return Fxx + Fxy",
            "test_cases": [
                "# 32.1 - Test case 1\nP = [10000000, 100000000]\nphi = 0\nR = 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\ntarget = 2.090553478330249e-06\n\nassert np.allclose(calculate_binding_force(P, phi, R, l, w, a, n), target, rtol=1e-4, atol=1e-8)",
                "# 32.1 - Test case 2\nP = [10000000, 100000000]\nphi = np.pi/2\nR = 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\ntarget = -2.17651746535146e-06\n\nassert np.allclose(calculate_binding_force(P, phi, R, l, w, a, n), target, rtol=1e-4, atol=1e-8)",
                "# 32.1 - Test case 3\nP = [1000000000, 1000000000]\nphi = np.pi/4\nR = 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\ntarget = -1.3592099786808985e-06\n\nassert np.allclose(calculate_binding_force(P, phi, R, l, w, a, n), target, rtol=1e-4, atol=1e-8)"
            ],
            "return_line":""
        },
        {
            "step_number": "32.2",
            "step_name": "Generate Hamiltonian",
            "step_description_prompt": "Develop a Python function to compute the Hamiltonian for the provided nanospherical system, considering the damping coefficient array and the linearized optical binding force acting upon the trapped nanospheres.",
            "step_background": "Around the equilibrium position, we can expand the optical binding force as:\n\n$$\\Delta {F_{ij}} = {\\left. {\\Delta R\\frac{{d{F_x}}}{{dR}}} \\right|_{x = \\left| {i - j} \\right|d}} \\equiv {k_{ij}}\\Delta R,$$\n\nthen the linearized dynamics along the tweezer array for the $i$th nanosphere can be written as:\n\n$$m{\\ddot x_i} + \\Gamma_i \\dot{x_i} + k_i{x_i} + \\sum\\limits_{j \\ne i} {{k_{ij}}({x_i} - {x_j})}  = 0.$$ \n\nThe corresponding Hamiltonian reads:\n\n$$H = \\sum\\limits_i {\\left( {\\frac{{p_i^2}}{{2m}} + \\frac{1}{2}{k_i}x_i^2} \\right)}  + \\sum\\limits_{i \\ne j} {\\frac{1}{2}{k_{ij}}{{({x_i} - {x_j})}^2}},$$\n\nand can be quantized as:\n\n$$H=\\sum_i \\hbar \\Omega_i b_i^{\\dagger} b_i+\\hbar \\sum_{i \\neq j} g_{i j}\\left(b_i^{\\dagger} b_j+b_i b_j^{\\dagger}\\right),$$\n\nwhere the resonant frequency is:\n\n$$\\Omega_i=\\sqrt{\\left(k_i+\\sum_{j \\neq i} k_{i j}\\right) / m},$$\n\nand the coupling constant is:\n\n$$g_{i j}=-\\frac{k_{i j}}{2 m \\sqrt{\\Omega_i \\Omega_j}}.$$ \n\nThis Hamiltonian can be expressed in matrix form as $H_{ii}= \\Omega_i$ and $H_{ij} = g_{i j}$. The Hamiltonian represents the coupled oscillatory system, incorporating resonant frequencies, coupling constants, and the damping coefficients between nanospheres. These parameters are derived from linearized binding forces.",
            "function_header": "def generate_hamiltonian(P, phi, R, l, w, a, n, h, N, rho, k_ij) -> np.ndarray:\n    \"\"\"\n    Generate the Hamiltonian matrix for N nanospheres in an optical tweezer array.\n\n    Args:\n        P (list): List of laser powers for each nanosphere (Watts)\n        phi (float): Polarization angle (radians)\n        R (float): Distance between adjacent nanospheres (meters)\n        l (float): Wavelength of optical tweezers (meters)\n        w (float): Beam waist of optical tweezers (meters)\n        a (float): Radius of nanospheres (meters)\n        n (float): Refractive index of nanospheres\n        h (float): Step size for numerical derivative (meters)\n        N (int): Number of nanospheres\n        rho (float): Density of nanospheres (kg/m\u00b3)\n\n    Returns:\n        numpy.ndarray: NxN Hamiltonian matrix\n    \"\"\"",
            "ground_truth_code": "def generate_hamiltonian(P, phi, R, l, w, a, n, h, N, rho, k_ij) -> np.ndarray:\n    \"\"\"\n    Generate the Hamiltonian matrix for N nanospheres in an optical tweezer array.\n\n    Args:\n        P (list): List of laser powers for each nanosphere (Watts)\n        phi (float): Polarization angle (radians)\n        R (float): Distance between adjacent nanospheres (meters)\n        l (float): Wavelength of optical tweezers (meters)\n        w (float): Beam waist of optical tweezers (meters)\n        a (float): Radius of nanospheres (meters)\n        n (float): Refractive index of nanospheres\n        h (float): Step size for numerical derivative (meters)\n        N (int): Number of nanospheres\n        rho (float): Density of nanospheres (kg/m\u00b3)\n        k_ij (np.ndarray): Pairwise binding forces (N)\n\n    Returns:\n        numpy.ndarray: NxN Hamiltonian matrix\n    \"\"\"\n    # Mass, polarizability, initial k_i\n    m = (4/3) * np.pi * (a**3) * rho\n    alpha = 4 * np.pi * epsilon_0 * a**3 * ((n**2 - 1)/(n**2 + 2))\n    k_i = np.array([(8 * alpha * p)/(np.pi * w**4 * epsilon_0 * c) for p in P])\n\n    # Resonant frequencies\n    Omega = np.zeros(N)\n    for i in range(N):\n        Omega[i] = np.sqrt((k_i[i] + 2*np.sum(k_ij[i,:]))/(2*m))\n\n    H = np.zeros((N, N))\n    np.fill_diagonal(H, Omega)\n\n    # Off-diagonal elements gij\n    for i in range(N):\n        for j in range(i+1, N):\n            g_ij = -k_ij[i,j]/(2 * m * np.sqrt(Omega[i] * Omega[j]))\n            H[i,j] = H[j,i] = g_ij\n\n    return H",
            "test_cases": [
                "# 32.2 - Test Case 1\nP = [100e-3, 100e-3, 100e-3, 100e-3, 100e-3]\nphi = np.pi / 2\nR = 0.99593306197 * 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\nh = 1e-8\nN = np.size(P)\nrho = 2.648e3\nk_ij = np.array([\n    [0.0, -7.681379869134715e-08, -4.4198493243744006e-08, -3.01656306194563e-08, -2.277029857871201e-08],\n    [-7.681379869134715e-08, 0.0, -7.681379869134715e-08, -4.4198493243744006e-08, -3.01656306194563e-08],\n    [-4.4198493243744006e-08, -7.681379869134715e-08, 0.0, -7.681379869134715e-08, -4.4198493243744006e-08],\n    [-3.01656306194563e-08, -4.4198493243744006e-08, -7.681379869134715e-08, 0.0, -7.681379869134715e-08],\n    [-2.277029857871201e-08, -3.01656306194563e-08, -4.4198493243744006e-08, -7.681379869134715e-08, 0.0]])\n\ntarget = [\n    [985147.05262796, 3519.91873466, 2026.13510524, 1382.4090176, 1042.19347808],\n    [3519.91873466, 982670.64171272, 3525.50675695, 2028.02156111, 1382.4090176],\n    [2026.13510524, 3525.50675695, 982026.55888623, 3525.50675695, 2026.13510524],\n    [1382.4090176, 2028.02156111, 3525.50675695, 982670.64171272, 3519.91873466],\n    [1042.19347808, 1382.4090176, 2026.13510524, 3519.91873466, 985147.05262796]\n]\noutput = generate_hamiltonian(P, phi, R, l, w, a, n, h, N, rho, k_ij)\nassert np.allclose(output, target, rtol=1e-3)",
                "# 32.2 - Test Case 2\nP = [100e-3, 100e-3, 100e-3, 100e-3, 100e-3]\nphi = np.pi / 2\nR = 2 * 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\nh = 1e-8\nN = np.size(P)\nrho = 2.648e3\nk_ij = np.array([\n    [0.0, -4.354835487054123e-08, -2.252061426059221e-08, -1.5106793817536392e-08, -1.1354570981112845e-08],\n    [-4.354835487054123e-08, 0.0, -4.354835487054123e-08, -2.252061426059221e-08, -1.5106793817536392e-08],\n    [-2.252061426059221e-08, -4.354835487054123e-08, 0.0, -4.354835487054123e-08, -2.252061426059221e-08],\n    [-1.5106793817536392e-08, -2.252061426059221e-08, -4.354835487054123e-08, 0.0, -4.354835487054123e-08],\n    [-1.1354570981112845e-08, -1.5106793817536392e-08, -2.252061426059221e-08, -4.354835487054123e-08, 0.0]])\n\n\ntarget = [\n    [9.88866250e+05, 1.98714355e+03, 1.02782631e+03, 6.89348389e+02, 5.17743766e+02],\n    [1.98714355e+03, 9.87397235e+05, 1.98896227e+03, 1.02841422e+03, 6.89348389e+02],\n    [1.02782631e+03, 1.98896227e+03, 9.87058624e+05, 1.98896227e+03, 1.02782631e+03],\n    [6.89348389e+02, 1.02841422e+03, 1.98896227e+03, 9.87397235e+05, 1.98714355e+03],\n    [5.17743766e+02, 6.89348389e+02, 1.02782631e+03, 1.98714355e+03, 9.88866250e+05]\n]\noutput = generate_hamiltonian(P, phi, R, l, w, a, n, h, N, rho, k_ij)\nassert np.allclose(output, target, rtol=1e-3)",
                "# 32.2 - Test Case 3\nP = [100e-3, 100e-3, 100e-3, 100e-3, 100e-3]\nphi = 0\nR = 1 * 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\nh = 1e-8\nN = np.size(P)\nrho = 2.648e3\nk_ij = np.array([\n    [0.0, -2.166999226554586e-08, -2.839815457291363e-09, -8.4861704309071e-10, -3.5907195757129063e-10],\n    [-2.166999226554586e-08, 0.0, -2.166999226554586e-08, -2.839815457291363e-09, -8.4861704309071e-10],\n    [-2.839815457291363e-09, -2.166999226554586e-08, 0.0, -2.166999226554586e-08, -2.839815457291363e-09],\n    [-8.4861704309071e-10, -2.839815457291363e-09, -2.166999226554586e-08, 0.0, -2.166999226554586e-08],\n    [-3.5907195757129063e-10, -8.4861704309071e-10, -2.839815457291363e-09, -2.166999226554586e-08, 0.0]])\n\n\ntarget = [\n    [9.91907992e+05, 9.85573690e+02, 1.29183297e+02, 3.86029400e+01, 1.63260875e+01],\n    [9.85573690e+02, 9.90938753e+05, 9.86100660e+02, 1.29240548e+02, 3.86029400e+01],\n    [1.29183297e+02, 9.86100660e+02, 9.90848130e+05, 9.86100660e+02, 1.29183297e+02],\n    [3.86029400e+01, 1.29240548e+02, 9.86100660e+02, 9.90938753e+05, 9.85573690e+02],\n    [1.63260875e+01, 3.86029400e+01, 1.29183297e+02, 9.85573690e+02, 9.91907992e+05]\n]\noutput = generate_hamiltonian(P, phi, R, l, w, a, n, h, N, rho, k_ij)\nassert np.allclose(output, target, rtol=1e-3)",
            ],
            "return_line":""
        },
        {
            "step_number": "32.3",
            "step_name": "Runge-Kutta for Phonon Dynamics",
            "step_description_prompt": "Write a Python function to implement the fourth-order Runge-Kutta (RK4) method to simulate phonon occupation dynamics of the trapped nanosphere system with the correlation matrix $C_{ij} = \\langle b_i^\\dagger b_j \rangle$ and the master equation in Lindblad form.",
            "step_background": "The Lindblad master equation governs the evolution of the correlation matrix $C_{ij} = \\langle b_i^\\dagger b_j \\rangle$, describing the dynamics of an open quantum system. The equation is given as:\n\n$$\\dot{C} = i[H, C] + \\{L, C\\} + M,$$\n\nwhere:\n\n- $H$ is the system Hamiltonian, which determines coherent dynamics,\n- $L = -\\frac{1}{2} \\operatorname{Diag}(\\Gamma_1, \\Gamma_2, \\ldots, \\Gamma_N)$ is the dissipation matrix describing loss rates, and\n- $M = \\operatorname{Diag}(\\Gamma_1 n_1^{\\text{th}}, \\Gamma_2 n_2^{\\text{th}}, \\ldots, \\Gamma_N n_N^{\\text{th}})$ is the reservoir matrix describing thermal effects.\n\nThe standard Fourth-Order Runge-Kutta (RK4) method is used to numerically solve this equation. At each time step $n$, the next state $C_{n+1}$ is computed as:\n\n$$C_{n+1} = C_n + \\frac{\\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4),$$\n\nwhere:\n\n$$k_1 = i[H, C_n] + \\{L, C_n\\} + M,$$\n$$k_2 = i[H, C_n + \\frac{1}{2}k_1 \\Delta t] + \\{L, C_n + \\frac{1}{2}k_1 \\Delta t\\} + M,$$\n$$k_3 = i[H, C_n + \\frac{1}{2}k_2 \\Delta t] + \\{L, C_n + \\frac{1}{2}k_2 \\Delta t\\} + M,$$\n$$k_4 = i[H, C_n + k_3 \\Delta t] + \\{L, C_n + k_3 \\Delta t\\} + M.$$\n\nThe RK4 method provides a robust way to integrate the Lindblad equation, ensuring stability and accuracy in capturing the system's evolution under dissipation and external fields.",
            "function_header": "def runge_kutta_dynamics(C0, H, L, M, t0, steps) -> np.ndarray:\n    \"\"\"\n     Simulates the evolution of the correlation matrix for a system of coupled nanospheres using the fourth-order Runge-Kutta (RK4) method.\n\n    Args:\n        C0 (numpy.ndarray): Initial correlation matrix (complex Hermitian).\n        H (numpy.ndarray): Hamiltonian matrix (real symmetric).\n        L (numpy.ndarray): Dissipation matrix (real diagonal).\n        M (numpy.ndarray): Reservoir matrix (real diagonal).\n        t0 (float): Total simulation time (seconds).\n        steps (int): Number of RK4 time steps.\n\n    Returns:\n        numpy.ndarray: Diagonal elements of the final correlation matrix representing phonon occupations.\n    \"\"\"",
            "ground_truth_code": "def runge_kutta_dynamics(C0, H, L, M, t0, steps) -> np.ndarray:\n    \"\"\"\n    Simulates the evolution of the correlation matrix for a system of coupled nanospheres using the fourth-order Runge-Kutta (RK4) method.\n\n    Args:\n        C0 (numpy.ndarray): Initial correlation matrix (complex Hermitian).\n        H (numpy.ndarray): Hamiltonian matrix (real symmetric).\n        L (numpy.ndarray): Dissipation matrix (real diagonal).\n        M (numpy.ndarray): Reservoir matrix (real diagonal).\n        t0 (float): Total simulation time (seconds).\n        steps (int): Number of RK4 time steps.\n\n    Returns:\n        numpy.ndarray: Diagonal elements of the final correlation matrix representing phonon occupations.\n    \"\"\"\n\n    delta_t = t0 / steps\n    C = np.array(C0, dtype=np.complex128)\n\n    def commutator(A, B) -> np.ndarray:\n        return np.dot(A, B) - np.dot(B, A)\n\n    def anticommutator(A, B) -> np.ndarray:\n        return np.dot(A, B) + np.dot(B, A)\n\n    for _ in range(steps):\n        k1 = 1j * commutator(H, C) + anticommutator(L, C) + M\n        k2 = 1j * commutator(H, C + 0.5 * k1 * delta_t) + anticommutator(L, C + 0.5 * k1 * delta_t) + M\n        k3 = 1j * commutator(H, C + 0.5 * k2 * delta_t) + anticommutator(L, C + 0.5 * k2 * delta_t) + M\n        k4 = 1j * commutator(H, C + k3 * delta_t) + anticommutator(L, C + k3 * delta_t) + M\n        C += (delta_t / 6) * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    return np.diag(C).real",
            "test_cases": [
              "# 32.3 - Test case 1\nn0 = [39549953.17, 197.25, 197.25, 197.25, 197.25]\nGamma = 0.001\nP = [100e-3, 100e-3, 100e-3, 100e-3, 100e-3]\nphi = np.pi / 2\nR = 0.99593306197 * 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\nh = 1e-6\nN = np.size(P)\nrho = 2.648e3\nC0 = np.diag(n0)\nH = [\n    [985147.05262796, 3519.91873466, 2026.13510524, 1382.4090176, 1042.19347808],\n    [3519.91873466, 982670.64171272, 3525.50675695, 2028.02156111, 1382.4090176 ],\n    [2026.13510524, 3525.50675695, 982026.55888623, 3525.50675695, 2026.13510524],\n    [1382.4090176, 2028.02156111, 3525.50675695, 982670.64171272, 3519.91873466],\n    [1042.19347808, 1382.4090176, 2026.13510524, 3519.91873466, 985147.05262796]\n]\nL = - Gamma * np.identity(N) / 2\nM = 197.25 * Gamma * np.identity(N) / 2\nt0 = 0.02\nsteps = 10000\ntarget = [ 6762435.17442855, 270122.3810029, 10004196.45838998, 19073172.61665625, 3440024.54245118 ]\nassert np.allclose(runge_kutta_dynamics(C0, H, L, M, t0, steps), target, rtol=1e-4, atol=1e-4)",
              "# 32.3 - Test case 2\nn0 = [197.25, 39549953.17, 39549953.17, 39549953.17, 39549953.17]\nGamma = 0.001\nP = [100e-3, 100e-3, 100e-3, 100e-3, 100e-3]\nphi = np.pi / 2\nR = 0.99593306197 * 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\nh = 1e-6\nN = np.size(P)\nrho = 2.648e3\nC0 = np.diag(n0)\nH = [\n    [985147.05262796, 3519.91873466, 2026.13510524, 1382.4090176, 1042.19347808],\n    [3519.91873466, 982670.64171272, 3525.50675695, 2028.02156111, 1382.4090176 ],\n    [2026.13510524, 3525.50675695, 982026.55888623, 3525.50675695, 2026.13510524],\n    [1382.4090176, 2028.02156111, 3525.50675695, 982670.64171272, 3519.91873466],\n    [1042.19347808, 1382.4090176, 2026.13510524, 3519.91873466, 985147.05262796]\n]\nL = - Gamma * np.identity(N) / 2\nM = 197.25 * Gamma * np.identity(N) / 2\nt0 = 0.05\nsteps = 10000\ntarget = [34044055.73846075, 36753347.53463306, 38766694.48731664, 36664745.76086929, 11963256.63062548]\nassert np.allclose(runge_kutta_dynamics(C0, H, L, M, t0, steps), target, rtol=1e-4, atol=1e-4)",
              "# 32.3 - Test case 3\nn0 = [39549953.17, 197.25, 197.25, 197.25, 197.25]\nGamma = 0.001\nP = [100e-3, 100e-3, 100e-3, 100e-3, 100e-3]\nphi = np.pi / 2\nR = 0.99593306197 * 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\nh = 1e-6\nN = np.size(P)\nrho = 2.648e3\nC0 = np.diag(n0)\nH = [\n    [985147.05262796, 3519.91873466, 2026.13510524, 1382.4090176, 1042.19347808],\n    [3519.91873466, 982670.64171272, 3525.50675695, 2028.02156111, 1382.4090176 ],\n    [2026.13510524, 3525.50675695, 982026.55888623, 3525.50675695, 2026.13510524],\n    [1382.4090176, 2028.02156111, 3525.50675695, 982670.64171272, 3519.91873466],\n    [1042.19347808, 1382.4090176, 2026.13510524, 3519.91873466, 985147.05262796]\n]\nL = - Gamma * np.identity(N) / 2\nM = 197.25 * Gamma * np.identity(N) / 2\nt0 = 0.05\nsteps = 50000\ntarget = [5504117.23331725, 2794825.43714492,  781478.48446118, 2883427.21090874, 27584916.3411524]\nassert np.allclose(runge_kutta_dynamics(C0, H, L, M, t0, steps), target, rtol=1e-4, atol=1e-4)",
              "# 32.3 - Test case 4\nn0 = [197.25, 197.25, 39549953.17, 197.25, 197.25]\nGamma = 0\nP = [100e-3, 100e-3, 100e-3, 100e-3, 100e-3]\nphi = np.pi / 2\nR = 0.99593306197 * 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\nh = 1e-6\nN = np.size(P)\nrho = 2.648e3\nC0 = np.diag(n0)\nH = [\n    [985147.05262796, 3519.91873466, 2026.13510524, 1382.4090176, 1042.19347808],\n    [3519.91873466, 982670.64171272, 3525.50675695, 2028.02156111, 1382.4090176 ],\n    [2026.13510524, 3525.50675695, 982026.55888623, 3525.50675695, 2026.13510524],\n    [1382.4090176, 2028.02156111, 3525.50675695, 982670.64171272, 3519.91873466],\n    [1042.19347808, 1382.4090176, 2026.13510524, 3519.91873466, 985147.05262796]\n]\nL = - Gamma * np.identity(N) / 2\nM = 197.25 * Gamma * np.identity(N) / 2\nt0 = 0.02\nsteps = 10000\nnf = runge_kutta_dynamics(C0, H, L, M, t0, steps)\ndiff = sum(nf) - sum(n0)\ntarget = (np.True_, np.True_)\ndef is_symmetric(array, rtol=1e-05, atol=1e-08):\n    return np.all(np.isclose(array, array[::-1], rtol=rtol, atol=atol))\nassert (abs(diff)<1e-6, is_symmetric(nf)) == target",
              "# 32.3 - Test case 5 - Different M coefficient, same step count range\nn0 = [39549953.17, 197.25, 197.25, 197.25, 197.25]\nGamma = 0.001\nP = [100e-3, 100e-3, 100e-3, 100e-3, 100e-3]\nphi = np.pi / 2\nR = 0.99593306197 * 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\nh = 1e-6\nN = np.size(P)\nrho = 2.648e3\nC0 = np.diag(n0)\nH = [\n    [985147.05262796, 3519.91873466, 2026.13510524, 1382.4090176, 1042.19347808],\n    [3519.91873466, 982670.64171272, 3525.50675695, 2028.02156111, 1382.4090176 ],\n    [2026.13510524, 3525.50675695, 982026.55888623, 3525.50675695, 2026.13510524],\n    [1382.4090176, 2028.02156111, 3525.50675695, 982670.64171272, 3519.91873466],\n    [1042.19347808, 1382.4090176, 2026.13510524, 3519.91873466, 985147.05262796]\n]\nL = - Gamma * np.identity(N) / 2\nM = 500 * Gamma * np.identity(N) / 2\nt0 = 0.02\nsteps = 10000\ntarget = [ 6762435.17442855, 270122.3810029, 10004196.45838998, 19073172.61665625, 3440024.54245118 ]\noutput = runge_kutta_dynamics(C0, H, L, M, t0, steps)\nassert np.allclose(output, target, rtol=1e-4, atol=1e-4)"
            ],   
            "return_line": ""
        }
    ],
    "general_solution": "def calculate_binding_force(P, phi, R, l, w, a, n) -> float:\n    \"\"\"\n    Function to calculate the optical binding force between two trapped nanospheres.\n\n    Args:\n        P (list of float): Laser powers for the two nanospheres (Watts).\n        phi (float): Polarization angle of the tweezers (radians).\n        R (float): Distance between adjacent nanospheres (meters).\n        l (float): Wavelength of the optical tweezers (meters).\n        w (float): Beam waist of the optical tweezers (meters).\n        a (float): Radius of the nanospheres (meters).\n        n (float): Refractive index of the nanospheres.\n\n    Returns:\n        float: Optical binding force (Newtons).\n    \"\"\"\n\n    # Wave number\n    k = 2 * np.pi / l\n    # Scalar polarizability\n    alpha = (4 * np.pi * epsilon_0 * a**3 * (n**2 - 1)) / (n**2 + 2)\n    # Electric fields\n    E1 = np.sqrt(4 * P[0] / (np.pi * w**2 * epsilon_0 * c))\n    E2 = np.sqrt(4 * P[1] / (np.pi * w**2 * epsilon_0 * c))\n    # Forces\n    Fxx = (\n        2 * alpha**2 * E1 * E2 * np.cos(phi)**2 / (8 * np.pi * epsilon_0 * R**4)\n        * (-3 * np.cos(k * R) - 3 * k * R * np.sin(k * R) + (k * R)**2 * np.cos(k * R))\n    )\n    Fxy = (\n        alpha**2 * E1 * E2 * np.sin(phi)**2 / (8 * np.pi * epsilon_0 * R**4)\n        * (3 * np.cos(k * R) + 3 * k * R * np.sin(k * R) - 2 * (k * R)**2 * np.cos(k * R) - (k * R)**3 * np.sin(k * R))\n    )\n    return Fxx + Fxy\n\ndef generate_hamiltonian(P, phi, R, l, w, a, n, h, N, rho, k_ij) -> np.ndarray:\n    \"\"\"\n    Generate the Hamiltonian matrix for N nanospheres in an optical tweezer array.\n\n    Args:\n        P (list): List of laser powers for each nanosphere (Watts)\n        phi (float): Polarization angle (radians)\n        R (float): Distance between adjacent nanospheres (meters)\n        l (float): Wavelength of optical tweezers (meters)\n        w (float): Beam waist of optical tweezers (meters)\n        a (float): Radius of nanospheres (meters)\n        n (float): Refractive index of nanospheres\n        h (float): Step size for numerical derivative (meters)\n        N (int): Number of nanospheres\n        rho (float): Density of nanospheres (kg/m\u00b3)\n        k_ij (np.ndarray): Pairwise binding forces (N)\n\n    Returns:\n        numpy.ndarray: NxN Hamiltonian matrix\n    \"\"\"\n    # Mass, polarizability, initial k_i\n    m = (4/3) * np.pi * (a**3) * rho\n    alpha = 4 * np.pi * epsilon_0 * a**3 * ((n**2 - 1)/(n**2 + 2))\n    k_i = np.array([(8 * alpha * p)/(np.pi * w**4 * epsilon_0 * c) for p in P])\n\n    # Resonant frequencies\n    Omega = np.zeros(N)\n    for i in range(N):\n        Omega[i] = np.sqrt((k_i[i] + 2*np.sum(k_ij[i,:]))/(2*m))\n\n    H = np.zeros((N, N))\n    np.fill_diagonal(H, Omega)\n\n    # Off-diagonal elements gij\n    for i in range(N):\n        for j in range(i+1, N):\n            g_ij = -k_ij[i,j]/(2 * m * np.sqrt(Omega[i] * Omega[j]))\n            H[i,j] = H[j,i] = g_ij\n\n    return H\n\ndef runge_kutta_dynamics(C0, H, L, M, t0, steps) -> np.ndarray:\n    \"\"\"\n    Simulates the evolution of the correlation matrix for a system of coupled nanospheres using the fourth-order Runge-Kutta (RK4) method.\n\n    Args:\n        C0 (numpy.ndarray): Initial correlation matrix (complex Hermitian).\n        H (numpy.ndarray): Hamiltonian matrix (real symmetric).\n        L (numpy.ndarray): Dissipation matrix (real diagonal).\n        M (numpy.ndarray): Reservoir matrix (real diagonal).\n        t0 (float): Total simulation time (seconds).\n        steps (int): Number of RK4 time steps.\n\n    Returns:\n        numpy.ndarray: Diagonal elements of the final correlation matrix representing phonon occupations.\n    \"\"\"\n\n    delta_t = t0 / steps\n    C = np.array(C0, dtype=np.complex128)\n\n    def commutator(A, B) -> np.ndarray:\n        return np.dot(A, B) - np.dot(B, A)\n\n    def anticommutator(A, B) -> np.ndarray:\n        return np.dot(A, B) + np.dot(B, A)\n\n    for _ in range(steps):\n        k1 = 1j * commutator(H, C) + anticommutator(L, C) + M\n        k2 = 1j * commutator(H, C + 0.5 * k1 * delta_t) + anticommutator(L, C + 0.5 * k1 * delta_t) + M\n        k3 = 1j * commutator(H, C + 0.5 * k2 * delta_t) + anticommutator(L, C + 0.5 * k2 * delta_t) + M\n        k4 = 1j * commutator(H, C + k3 * delta_t) + anticommutator(L, C + k3 * delta_t) + M\n        C += (delta_t / 6) * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    return np.diag(C).real\n\ndef solve_multiparticle_dynamics(N, t0, R, l, phi, Gamma, P, n0, w, a, n, h, rho, steps) -> list:\n    \"\"\"\n    Simulates phonon occupation dynamics in an optical tweezer array.\n\n    Args:\n        N (int): Number of nanospheres.\n        t0 (float): Time for simulation (seconds).\n        R (float): Distance between adjacent nanospheres (meters).\n        l (float): Wavelength of optical tweezers (meters).\n        phi (float): Polarization angle (radians).\n        Gamma (list): Damping coefficients for each nanosphere.\n        P (list): Powers of optical tweezers (Watts).\n        n0 (list): Initial phonon occupation numbers.\n        w (float): Beam waist of optical tweezers (meters).\n        a (float): Radius of nanospheres (meters).\n        n (float): Refractive index of the nanospheres.\n        h (float): Step size for numerical derivative (meters)\n        rho (float): Density of nanospheres (kg/m\u00b3).\n        steps (int): Number of RK4 time steps.\n\n    Returns:\n        list: Phonon occupation numbers at time t0.\n    \"\"\"\n\n    # Get kij using numerical derivative of binding force, so we can remove calculate_binding_force dependency in generate_hamiltonian\n    k_ij = np.zeros((N, N))\n    for i in range(N):\n        for j in range(i+1, N):\n            # Force at R_ij + h and R_ij - h\n            R_ij = abs(i - j) * R\n\n            F_plus = calculate_binding_force([P[i], P[j]], phi, R_ij + h, l, w, a, n)\n            F_minus = calculate_binding_force([P[i], P[j]], phi, R_ij - h, l, w, a, n)\n\n            k_ij[i,j] = k_ij[j,i] = (F_plus - F_minus)/(2*h)\n\n    H = generate_hamiltonian(P, phi, R, l, w, a, n, h, N, rho, k_ij)\n\n    C0 = np.diag(n0)\n    L = - Gamma * np.identity(N) / 2\n    M = 100 * Gamma * np.identity(N) / 2\n    nf = runge_kutta_dynamics(C0, H, L, M, t0, steps)\n    return nf.tolist()",
    "general_tests": [
      "# General test 1\nn0 = [39549953.17, 197.25, 197.25, 197.25, 197.25]\nGamma = 0.001\nP = [100e-3, 100e-3, 100e-3, 100e-3, 100e-3]\nphi = np.pi / 2\nR = 0.99593306197 * 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\nh = 1e-8 # was 1e-6 in original version, but we need a smaller step\nN = np.size(P)\nrho = 2.648e3\nt0 = 0.02\nsteps = 10000\n\ntarget = [6762435.17442855, 270122.3810029, 10004196.45838998, 19073172.61665625, 3440024.54245118]\noutput = solve_multiparticle_dynamics(N, t0, R, l, phi, Gamma, P, n0, w, a, n, h, rho, steps)\n\nassert np.allclose(output, target, rtol=1e-1)",
      "# General test case 2\nn0 = [197.25, 39549953.17, 39549953.17, 39549953.17, 39549953.17]\nGamma = 0.001\nP = [100e-3, 100e-3, 100e-3, 100e-3, 100e-3]\nphi = np.pi / 2\nR = 0.99593306197 * 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\nh = 1e-8\nN = np.size(P)\nrho = 2.648e3\nM = 197.25 * Gamma * np.identity(N) / 2\nt0 = 0.05\nsteps = 10000\n\ntarget = [34044055.73846075, 36753347.53463306, 38766694.48731664, 36664745.76086929, 11963256.63062548]\noutput = solve_multiparticle_dynamics(N, t0, R, l, phi, Gamma, P, n0, w, a, n, h, rho, steps)\n\nassert np.allclose(output, target, rtol=1e-1)",
      "# General test case 3\nn0 = [39549953.17, 197.25, 197.25, 197.25, 197.25]\nGamma = 0.001\nP = [100e-3, 100e-3, 100e-3, 100e-3, 100e-3]\nphi = np.pi / 2\nR = 0.99593306197 * 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\nh = 1e-8\nN = np.size(P)\nrho = 2.648e3\nM = 197.25 * Gamma * np.identity(N) / 2\nt0 = 0.05\nsteps = 10000\n\noutput = solve_multiparticle_dynamics(N, t0, R, l, phi, Gamma, P, n0, w, a, n, h, rho, steps)\ntarget = [5504117.23331725, 2794825.43714492, 781478.48446118, 2883427.21090874, 27584916.3411524]\n\nassert np.allclose(output, target, rtol=5e-1)",
      "# General test case 4\nn0 = [197.25, 197.25, 39549953.17, 197.25, 197.25]\nGamma = 0\nP = [100e-3, 100e-3, 100e-3, 100e-3, 100e-3]\nphi = np.pi / 2\nR = 0.99593306197 * 1550e-9\nl = 1550e-9\nw = 600e-9\na = 100e-9\nn = 1.444\nh = 1e-6\nN = np.size(P)\nrho = 2.648e3\nM = 197.25 * Gamma * np.identity(N) / 2\nt0 = 0.02\nsteps = 10000\n\nnf = solve_multiparticle_dynamics(N, t0, R, l, phi, Gamma, P, n0, w, a, n, h, rho, steps)\ndiff = sum(nf) - sum(n0)\ntarget = (np.True_, np.True_)\n\ndef is_symmetric(array, rtol=1e-05, atol=1e-08):\n    return np.all(np.isclose(array, array[::-1], rtol=rtol, atol=atol))\nassert (abs(diff)<1e-6, is_symmetric(nf)) == target"
    ]
}
