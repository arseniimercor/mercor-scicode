{
  "problem_id": "51",
  "problem_name": "velocity_verlet",
  "problem_description_main": "Implement the velocity verlet algorithm to simulate a system of particles interacting through a Lennard-Jones potential. Assume that the particles are in a periodic system, and we'll use the continuous version of the Lennard-Jones potential where the potential is set to 0 after a cutoff distance $r_c$.\nWrite a function that takes the position and velocities of the particles in the system, the lattice constants of computational cell, integration time step and the cutoff distance $r_c$ as inputs, outputs the updated position and velocity as outputs.\nFor simplicity, use Lennard-Jones units given by energy  $\\epsilon$, length $\\sigma$, and the atom mass $m$.  For example, units of time are $m^\\frac{1}{2}\\sigma\\epsilon^{-\\frac{1}{2}}.$\n",
  "problem_background_main": "The continuous version of the Lennard-Jones potential is\n\\begin{equation}\n\\phi(r) =\n\\begin{cases}\n4\\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12}-\\left(\\frac{\\sigma}{r}\\right)^6\\right]-4\\epsilon\\left[\\left(\\frac{\\sigma}{r_c}\\right)^{12}-\\left(\\frac{\\sigma}{r_c}\\right)^6\\right], & r<r_c \\\\\n 0, & r\\ge r_c\n \\end{cases}\n \\end{equation}\n\n\nThe velocity verlet algorithm updates are given by the equations below. \\\nGiven the set of positions of velocities of all particles in a N-atom system at time t, \\\nthe positions, forces, and velocities at time t+dt are computed as follows:\n\n1. Calculate for all atoms $l$, \n\\begin{equation}\n\\vec{r_l}(t+dt) = \\vec{r_l}(t) + \\vec{v_l}(t)dt + \\frac{1}{2}\\frac{\\vec{f_l}(t)}{m_l}dt^2\n\\end{equation}\n\n2. Calculate for all atoms $l$,\n\\begin{equation}\n\\vec{f_l}(t+dt) = -\\vec{\\nabla_l}E_{pot}(\\vec{r_1}(t+dt), ... , \\vec{r_N}(t+dt))\n\\end{equation}\n\n3. Calculate for all atoms $l$,\n\\begin{equation}\n\\vec{v_l}(t+dt) = \\vec{v_l}(t) + \\frac{\\vec{f_l}(t+dt)+\\vec{f_l}(t)}{2m_l} dt\n\\end{equation}\n\nwhere $\\vec{r_l}$, $\\vec{f_l}$, $\\vec{v_l}$, $m_l$ are the position, force, velocity and mass of the l-th particle in the system. $E_{pot}$ is the potential energy.\n",
  "general_solution": "def velocity_verlet(\n    atoms:np.ndarray, \n    velocities:np.ndarray, \n    latvec:np.ndarray, \n    dt:float, \n    rcut:float,\n    n_steps:int\n) -> tuple[np.ndarray, np.ndarray, np.ndarray]:\n  '''Implementation of an MD simulation of a Lennard-Jones system using velocity verlet.\n  \n  Args:\n    atoms: positions of each atom of shape (n_atoms, 3)\n    velocities: velocities of each atom of shape (n_atoms, 3)\n    latvec: Lattice vectors of the computational cell.\n    dt: time step for the velocity verlet integration.\n    rcut: cutoff distance for the continuous Lennard-Jones potential.\n    n_steps: number of time steps to simulate.\n  Returns:\n    atoms_trajectory: atom positions at each step of the simulation. Shape (n_atoms, 3, n_steps)\n    velocities_new: atom velocities at each step of the simulation. Shape (n_atoms, 3, n_steps)\n    E_pot_new: potential energy of the system at each step of the simulation. Shape (n_steps,)\n  '''\n  atoms_trajectory = []\n  velocities_trajectory = []\n  E_pot_trajectory = []\n  for _ in range(n_steps):\n    atoms, velocities, E_pot = velocity_verlet_update(atoms, velocities, latvec, dt, rcut)\n    atoms_trajectory.append(atoms)\n    velocities_trajectory.append(velocities)\n    E_pot_trajectory.append(E_pot)\n  return np.array(atoms_trajectory), np.array(velocities_trajectory), np.array(E_pot_trajectory)\n\ndef velocity_verlet_update(\n    atoms:np.ndarray, \n    velocities:np.ndarray, \n    latvec:np.ndarray, \n    dt:float, \n    rcut:float\n) -> tuple[np.ndarray, np.ndarray, float]:\n  '''One update step of the velocity verlet algorithm.\n\n  Args:\n    atoms: positions of each atom of shape (n_atoms, 3)\n    velocities: velocities of each atom of shape (n_atoms, 3)\n    latvec: Lattice vectors of the computational cell.\n    dt: time step for the velocity verlet integration.\n    rcut: cutoff distance for the continuous Lennard-Jones potential.\n  Returns:\n    atoms_new: updated atom positions of shape (n_atoms, 3)\n    velocities_new: updated velocities of shape (n_atoms, 3)\n    E_pot_new: updated potential energy of the system\n  '''\n  E_pot, forces = calculate_potential_energy_periodic(atoms, latvec, rcut)\n  atoms_new = atoms + velocities*dt + 0.5*forces*dt*dt\n  E_pot_new, forces_new = calculate_potential_energy_periodic(atoms_new, latvec, rcut)\n  velocities_new = velocities + 0.5*(forces_new+forces)*dt\n  return atoms_new, velocities_new, E_pot_new\n\n\ndef calculate_potential_energy_periodic(\n    atoms: np.ndarray,\n    latvec: np.ndarray,\n    rcut: float\n) -> tuple[float, np.ndarray]:\n  '''Calculate the potential energy and forces on a system of atoms in a periodic system.\n\n  Args:\n    atoms: positions of each atom of shape (n_atoms, 3)\n    latvec: Lattice vectors of the computational cell.\n    rcut: cutoff distance for the continuous Lennard-Jones potential.\n\n  Returns:\n    total energy, forces of shape (n_atoms, 3)\n  '''\n  l_max = np.ceil(rcut/latvec[0,0]).astype(int)\n  m_max = np.ceil(rcut/latvec[1,1]).astype(int)\n  n_max = np.ceil(rcut/latvec[2,2]).astype(int)\n  ecut = rcut**-12 - rcut**-6\n\n  e_tot = 0\n  forces = np.zeros((len(atoms),3))\n  for i in range(len(atoms)):\n    for j in range(len(atoms)):\n      for l in range(-l_max, l_max+1):\n        for m in range(-m_max, m_max+1):\n          for n in range(-n_max, n_max+1):\n            # latvec are row vectors\n            disp_ij = atoms[i]-atoms[j] + np.matmul(np.array([l,m,n]), latvec)\n            r_ij = np.linalg.norm(disp_ij)\n            if r_ij>0 and r_ij < rcut:\n              e_tot += -r_ij**-6 + r_ij**-12 - ecut\n              forces[i] += 24*(2*r_ij**-14 -r_ij**-8)*disp_ij\n  e_tot*=2\n  return e_tot, forces\n",
  "general_tests": [
    "# test 1 - 2x2x2 FCC crystal at initial T=0.2\n# rtol and atol are adjusted on a case-by-case basis\ndef calculate_E_kin(velocities):\n  return 0.5 * np.linalg.norm(velocities)**2\n\ndef calculate_T(velocities):\n  E_kin = calculate_E_kin(velocities)\n  T = E_kin*2/(3*len(velocities))\n  return T\n\ndef initialize_velocities(n_atoms, T_target=None):\n  np.random.seed(0)\n  velocities = np.random.uniform(-1,1,(n_atoms,3))\n  if T_target is not None:\n    velocities*=np.sqrt(T_target/calculate_T(velocities))\n  return velocities\n\natoms = np.array([[0.        , 0.        , 0.        ],\n       [0.79370053, 0.79370053, 0.        ],\n       [0.        , 0.79370053, 0.79370053],\n       [0.79370053, 0.        , 0.79370053],\n       [0.        , 0.        , 1.58740105],\n       [0.79370053, 0.79370053, 1.58740105],\n       [0.        , 0.79370053, 2.38110158],\n       [0.79370053, 0.        , 2.38110158],\n       [0.        , 1.58740105, 0.        ],\n       [0.79370053, 2.38110158, 0.        ],\n       [0.        , 2.38110158, 0.79370053],\n       [0.79370053, 1.58740105, 0.79370053],\n       [0.        , 1.58740105, 1.58740105],\n       [0.79370053, 2.38110158, 1.58740105],\n       [0.        , 2.38110158, 2.38110158],\n       [0.79370053, 1.58740105, 2.38110158],\n       [1.58740105, 0.        , 0.        ],\n       [2.38110158, 0.79370053, 0.        ],\n       [1.58740105, 0.79370053, 0.79370053],\n       [2.38110158, 0.        , 0.79370053],\n       [1.58740105, 0.        , 1.58740105],\n       [2.38110158, 0.79370053, 1.58740105],\n       [1.58740105, 0.79370053, 2.38110158],\n       [2.38110158, 0.        , 2.38110158],\n       [1.58740105, 1.58740105, 0.        ],\n       [2.38110158, 2.38110158, 0.        ],\n       [1.58740105, 2.38110158, 0.79370053],\n       [2.38110158, 1.58740105, 0.79370053],\n       [1.58740105, 1.58740105, 1.58740105],\n       [2.38110158, 2.38110158, 1.58740105],\n       [1.58740105, 2.38110158, 2.38110158],\n       [2.38110158, 1.58740105, 2.38110158]])\nlatcnt = (2**(1/6)*np.sqrt(2))\nlatvec = np.identity(3)*latcnt*np.array([2,2,2])\nvelocities = initialize_velocities(len(atoms), T_target=0.2)\ndt, rcut = 0.01, 1.3\natoms_traj, velocities_traj, E_pot_traj = velocity_verlet(atoms, velocities, latvec, dt, rcut, 100)\n# temperature should equilibrate after ~50 steps to ~0.1\nTs = [calculate_T(velocities) for velocities in velocities_traj]\nassert np.isclose(np.mean(Ts[50:]),0.1, rtol=2e-2, atol=2e-2)\n# total energy should not drift\ntotal_energies = [E_pot_traj[i]+calculate_E_kin(velocities_traj[i]) for i in range(len(velocities_traj))]\nassert np.allclose(np.array(total_energies)/-56.25,np.ones(100),rtol=1e-3,atol=1e-3)",
    "# test 2 - 1x1x1 FCC crystal at initial T=0.2, single vacancy\n# rtol and atol are adjusted on a case-by-case basis\ndef calculate_E_kin(velocities):\n  return 0.5 * np.linalg.norm(velocities)**2\n\ndef calculate_T(velocities):\n  E_kin = calculate_E_kin(velocities)\n  T = E_kin*2/(3*len(velocities))\n  return T\n\ndef initialize_velocities(n_atoms, T_target=None):\n  np.random.seed(0)\n  velocities = np.random.uniform(-1,1,(n_atoms,3))\n  if T_target is not None:\n    velocities*=np.sqrt(T_target/calculate_T(velocities))\n  return velocities\n\natoms = np.array([[0.79370053, 0.79370053, 0.        ],\n       [0.        , 0.79370053, 0.79370053],\n       [0.79370053, 0.        , 0.79370053]])\nlatcnt = (2**(1/6)*np.sqrt(2))\nlatvec = np.identity(3)*latcnt*np.array([2,2,2])\nvelocities = np.array([[-0.1,-0.05,0],[0.1,0.05,-0.1],[0.05,-0.1,0.1]])\ndt, rcut = 0.01, 1.3\natoms_traj, velocities_traj, E_pot_traj = velocity_verlet(atoms, velocities, latvec, dt, rcut, 100)\nassert np.allclose(atoms_traj[-1], np.array([[ 0.78820291,  0.68950762, -0.04011873],\n       [ 0.04147958,  0.80786198,  0.78855439],\n       [ 0.80771856, -0.00996855,  0.8389654 ]]),rtol=1e-3,atol=1e-3)",
    "# test 3 - 2x2x2 FCC crystal at initial T=0.2, large time step\n# rtol and atol are adjusted on a case-by-case basis\ndef calculate_E_kin(velocities):\n  return 0.5 * np.linalg.norm(velocities)**2\n\ndef calculate_T(velocities):\n  E_kin = calculate_E_kin(velocities)\n  T = E_kin*2/(3*len(velocities))\n  return T\n\ndef initialize_velocities(n_atoms, T_target=None):\n  np.random.seed(0)\n  velocities = np.random.uniform(-1,1,(n_atoms,3))\n  if T_target is not None:\n    velocities*=np.sqrt(T_target/calculate_T(velocities))\n  return velocities\n\natoms = np.array([[0.        , 0.        , 0.        ],\n       [0.79370053, 0.79370053, 0.        ],\n       [0.        , 0.79370053, 0.79370053],\n       [0.79370053, 0.        , 0.79370053],\n       [0.        , 0.        , 1.58740105],\n       [0.79370053, 0.79370053, 1.58740105],\n       [0.        , 0.79370053, 2.38110158],\n       [0.79370053, 0.        , 2.38110158],\n       [0.        , 1.58740105, 0.        ],\n       [0.79370053, 2.38110158, 0.        ],\n       [0.        , 2.38110158, 0.79370053],\n       [0.79370053, 1.58740105, 0.79370053],\n       [0.        , 1.58740105, 1.58740105],\n       [0.79370053, 2.38110158, 1.58740105],\n       [0.        , 2.38110158, 2.38110158],\n       [0.79370053, 1.58740105, 2.38110158],\n       [1.58740105, 0.        , 0.        ],\n       [2.38110158, 0.79370053, 0.        ],\n       [1.58740105, 0.79370053, 0.79370053],\n       [2.38110158, 0.        , 0.79370053],\n       [1.58740105, 0.        , 1.58740105],\n       [2.38110158, 0.79370053, 1.58740105],\n       [1.58740105, 0.79370053, 2.38110158],\n       [2.38110158, 0.        , 2.38110158],\n       [1.58740105, 1.58740105, 0.        ],\n       [2.38110158, 2.38110158, 0.        ],\n       [1.58740105, 2.38110158, 0.79370053],\n       [2.38110158, 1.58740105, 0.79370053],\n       [1.58740105, 1.58740105, 1.58740105],\n       [2.38110158, 2.38110158, 1.58740105],\n       [1.58740105, 2.38110158, 2.38110158],\n       [2.38110158, 1.58740105, 2.38110158]])\nlatcnt = (2**(1/6)*np.sqrt(2))\nlatvec = np.identity(3)*latcnt*np.array([2,2,2])\nvelocities = initialize_velocities(len(atoms), T_target=0.2)\ndt, rcut = 0.2, 1.3\natoms_traj, velocities_traj, E_pot_traj = velocity_verlet(atoms, velocities, latvec, dt, rcut, 10)\n# temperature should blow up\nTs = [calculate_T(velocities) for velocities in velocities_traj]\nassert Ts[-1]>1e4"
  ],
  "required_dependencies": "import numpy as np\n",
  "problem_io": "def velocity_verlet(\n    atoms:np.ndarray, \n    velocities:np.ndarray, \n    latvec:np.ndarray, \n    dt:float, \n    rcut:float,\n    n_steps:int\n) -> tuple[np.ndarray, np.ndarray, np.ndarray]:\n  '''Implementation of an MD simulation of a Lennard-Jones system using velocity verlet.\n  \n  Args:\n    atoms: positions of each atom of shape (n_atoms, 3)\n    velocities: velocities of each atom of shape (n_atoms, 3)\n    latvec: Lattice vectors of the computational cell.\n    dt: time step for the velocity verlet integration.\n    rcut: cutoff distance for the continuous Lennard-Jones potential.\n    n_steps: number of time steps to simulate.\n  Returns:\n    atoms_trajectory: atom positions at each step of the simulation. Shape (n_atoms, 3, n_steps)\n    velocities_new: atom velocities at each step of the simulation. Shape (n_atoms, 3, n_steps)\n    E_pot_new: potential energy of the system at each step of the simulation. Shape (n_steps,)\n  '''",
  "sub_steps": [
    {
      "step_number": "51.1",
      "step_name": "calculate_potential_energy_periodic",
      "step_description_prompt": "Calculate the continuous version of the Lennard-Jones potential energy, and corresponding forces on a system of atoms in a periodic system.\n",
      "step_background": "The continuous version of the Lennard-Jones potential is\n\\begin{equation}\n\\phi(r) =\n\\begin{cases}\n4\\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12}-\\left(\\frac{\\sigma}{r}\\right)^6\\right]-4\\epsilon\\left[\\left(\\frac{\\sigma}{r_c}\\right)^{12}-\\left(\\frac{\\sigma}{r_c}\\right)^6\\right], & r<r_c \\\\\n 0, & r\\ge r_c\n \\end{cases}\n \\end{equation}\n",
      "ground_truth_code": "def calculate_potential_energy_periodic(\n    atoms: np.ndarray,\n    latvec: np.ndarray,\n    rcut: float\n) -> tuple[float, np.ndarray]:\n  '''Calculate the potential energy and forces on a system of atoms in a periodic system.\n\n  Args:\n    atoms: positions of each atom of shape (n_atoms, 3)\n    latvec: Lattice vectors of the computational cell.\n    rcut: cutoff distance for the continuous Lennard-Jones potential.\n\n  Returns:\n    total energy, forces of shape (n_atoms, 3)\n  '''\n  l_max = np.ceil(rcut/latvec[0,0]).astype(int)\n  m_max = np.ceil(rcut/latvec[1,1]).astype(int)\n  n_max = np.ceil(rcut/latvec[2,2]).astype(int)\n  ecut = rcut**-12 - rcut**-6\n\n  e_tot = 0\n  forces = np.zeros((len(atoms),3))\n  for i in range(len(atoms)):\n    for j in range(len(atoms)):\n      for l in range(-l_max, l_max+1):\n        for m in range(-m_max, m_max+1):\n          for n in range(-n_max, n_max+1):\n            # latvec are row vectors\n            disp_ij = atoms[i]-atoms[j] + np.matmul(np.array([l,m,n]), latvec)\n            r_ij = np.linalg.norm(disp_ij)\n            if r_ij>0 and r_ij < rcut:\n              e_tot += -r_ij**-6 + r_ij**-12 - ecut\n              forces[i] += 24*(2*r_ij**-14 -r_ij**-8)*disp_ij\n  e_tot*=2\n  return e_tot, forces\n",
      "function_header": "def calculate_potential_energy_periodic(\n    atoms: np.ndarray,\n    latvec: np.ndarray,\n    rcut: float\n) -> tuple[float, np.ndarray]:\n  '''Calculate the potential energy and forces on a system of atoms in a periodic system.\n\n  Args:\n    atoms: positions of each atom of shape (n_atoms, 3)\n    latvec: Lattice vectors of the computational cell.\n    rcut: cutoff distance for the continuous Lennard-Jones potential.\n\n  Returns:\n    total energy, forces of shape (n_atoms, 3)\n  '''",
      "test_cases": [
        "atoms = np.array([[0.,  0.,  0., ],\n [0.5 ,0.5 ,0. ],\n [0.  ,0.5, 0.5],\n [0.5 ,0.  ,0.5]])\nlatcnt = (2**(1/6)*np.sqrt(2))\natoms *=latcnt\nlatvec = np.identity(3)*latcnt\ne_tot_gt = -8.23159\nforces_gt = np.zeros(atoms.shape)\nrcut = 1.3\n\ne_tot, forces = calculate_potential_energy_periodic(atoms, latvec, rcut)\nassert np.isclose(e_tot, e_tot_gt, rtol=1e-4, atol=1e-4)\nassert np.allclose(forces, forces_gt, rtol=1e-4, atol=1e-4)\n",
        "atoms = np.array([[0.,  0.,  0., ],\n [0.5 ,0.5 ,0. ],\n [0.  ,0.5, 0.5],\n [0.5 ,0.  ,0.5]])\nlatcnt = (2**(1/6)*np.sqrt(2))\natoms *=latcnt\nlatvec = np.identity(3)*latcnt\ne_tot_gt = -33.24205\nforces_gt = np.zeros(atoms.shape)\nrcut = 6\n\ne_tot, forces = calculate_potential_energy_periodic(atoms, latvec, rcut)\nassert np.isclose(e_tot, e_tot_gt, rtol=1e-4, atol=1e-4)\nassert np.allclose(forces, forces_gt, rtol=1e-4, atol=1e-4)\n",
        "atoms = np.array([[0.2,  0.2,  0.2, ],\n [0.5 ,0.5 ,0. ],\n [0.  ,0.5, 0.5],\n [0.5 ,0.  ,0.5]])\nlatcnt = (2**(1/6)*np.sqrt(2))\natoms *=latcnt\nlatvec = np.identity(3)*latcnt\ne_tot_gt = 340.15132\nforces_gt = np.array([[-1736.45363574, -1736.45363574, -1736.45363574],\n       [ 1300.81978431,  1300.81978431,  -865.18593289],\n       [ -865.18593289,  1300.81978431,  1300.81978431],\n       [ 1300.81978431,  -865.18593289,  1300.81978431]])\nrcut = 1.3\n\ne_tot, forces = calculate_potential_energy_periodic(atoms, latvec, rcut)\nassert np.isclose(e_tot, e_tot_gt, rtol=1e-4, atol=1e-4)\nassert np.allclose(forces, forces_gt, rtol=1e-4, atol=1e-4)\n"
      ]
    },
    {
      "step_number": "51.2",
      "step_name": "velocity_verlet_update",
      "step_description_prompt": "Implement one update step of the velocity verlet algorithm. Assume you have access to a function called calculate_energy_forces with the following docstring:\n\ndef calculate_potential_energy_periodic(\n    atoms: np.ndarray,\n    latvec: np.ndarray,\n    rcut: float\n) -> tuple[float, np.ndarray]:\n  '''Calculate the potential energy and forces on a system of atoms in a periodic system.\n\n  Args:\n    atoms: positions of each atom of shape (n_atoms, 3)\n    latvec: Lattice vectors of the computational cell.\n    rcut: cutoff distance for the continuous Lennard-Jones potential.\n\n  Returns:\n    total energy, forces of shape (n_atoms, 3)\n  '''\n",
      "step_background": "The velocity verlet algorithm updates are given by the equations below. Given the set of positions of velocities of all particles in a N-atom system at time t, the positions, forces, and velocities at time t+dt are computed as follows:\n\n1. Calculate for all atoms $l$, \n\\begin{equation}\n\\vec{r_l}(t+dt) = \\vec{r_l}(t) + \\vec{v_l}(t)dt + \\frac{1}{2}\\frac{\\vec{f_l}(t)}{m_l}dt^2\n\\end{equation}\n\n2. Calculate for all atoms $l$,\n\\begin{equation}\n\\vec{f_l}(t+dt) = -\\vec{\\nabla_l}E_{pot}(\\vec{r_1}(t+dt), ... , \\vec{r_N}(t+dt))\n\\end{equation}\n\n3. Calculate for all atoms $l$,\n\\begin{equation}\n\\vec{v_l}(t+dt) = \\vec{v_l}(t) + \\frac{\\vec{f_l}(t+dt)+\\vec{f_l}(t)}{2m_l} dt\n\\end{equation}\n\nwhere $\\vec{r_l}$, $\\vec{f_l}$, $\\vec{v_l}$, $m_l$ are the position, force, velocity and mass of the l-th particle in the system. $E_{pot}$ is the potential energy.\n",
      "ground_truth_code": "def velocity_verlet_update(\n    atoms:np.ndarray, \n    velocities:np.ndarray, \n    latvec:np.ndarray, \n    dt:float, \n    rcut:float\n) -> tuple[np.ndarray, np.ndarray, float]:\n  '''One update step of the velocity verlet algorithm.\n\n  Args:\n    atoms: positions of each atom of shape (n_atoms, 3)\n    velocities: velocities of each atom of shape (n_atoms, 3)\n    latvec: Lattice vectors of the computational cell.\n    dt: time step for the velocity verlet integration.\n    rcut: cutoff distance for the continuous Lennard-Jones potential.\n  Returns:\n    atoms_new: updated atom positions of shape (n_atoms, 3)\n    velocities_new: updated velocities of shape (n_atoms, 3)\n    E_pot_new: updated potential energy of the system\n  '''\n  E_pot, forces = calculate_potential_energy_periodic(atoms, latvec, rcut)\n  atoms_new = atoms + velocities*dt + 0.5*forces*dt*dt\n  E_pot_new, forces_new = calculate_potential_energy_periodic(atoms_new, latvec, rcut)\n  velocities_new = velocities + 0.5*(forces_new+forces)*dt\n  return atoms_new, velocities_new, E_pot_new\n",
      "function_header": "def velocity_verlet_update(\n    atoms:np.ndarray, \n    velocities:np.ndarray, \n    latvec:np.ndarray, \n    dt:float, \n    rcut:float\n) -> tuple[np.ndarray, np.ndarray, float]:\n  '''One update step of the velocity verlet algorithm.\n\n  Args:\n    atoms: positions of each atom of shape (n_atoms, 3)\n    velocities: velocities of each atom of shape (n_atoms, 3)\n    latvec: Lattice vectors of the computational cell.\n    dt: time step for the velocity verlet integration.\n    rcut: cutoff distance for the continuous Lennard-Jones potential.\n  Returns:\n    atoms_new: updated atom positions of shape (n_atoms, 3)\n    velocities_new: updated velocities of shape (n_atoms, 3)\n    E_pot_new: updated potential energy of the system\n  '''",
      "test_cases": [
        "# case 1 - zero forces, uniform velocity\ndef calculate_potential_energy_periodic(atoms, latvec, rcut):\n  return 0, np.zeros(atoms.shape)\natoms = np.array([[0.,  0.,  0., ],\n [0.5 ,0.5 ,0. ],\n [0.  ,0.5, 0.5],\n [0.5 ,0.  ,0.5]])\nlatcnt = (2**(1/6)*np.sqrt(2))\natoms *=latcnt\nlatvec = np.identity(3)*latcnt\nvelocities = np.ones((len(atoms),3))\natoms_new, velocities_new, epot_new = velocity_verlet_update(atoms, velocities, latvec, 0.01, 1.3)\nassert np.allclose(atoms_new, atoms+0.01, rtol=1e-4, atol=1e-4)\nassert np.allclose(velocities_new, velocities, rtol=1e-4, atol=1e-4)\nassert np.isclose(epot_new, 0, rtol=1e-4, atol=1e-4)\n",
        "# case 2 - zero velocity, uniform forces\ndef calculate_potential_energy_periodic(atoms, latvec, rcut):\n  return -7777, np.ones(atoms.shape)\natoms = np.array([[0.,  0.,  0., ],\n [0.5 ,0.5 ,0. ],\n [0.  ,0.5, 0.5],\n [0.5 ,0.  ,0.5]])\nlatcnt = (2**(1/6)*np.sqrt(2))\natoms *=latcnt\nlatvec = np.identity(3)*latcnt\nvelocities = np.zeros((len(atoms),3))\natoms_new, velocities_new, epot_new = velocity_verlet_update(\n    atoms, velocities, latvec, 0.1, 1.3)\nassert np.allclose(atoms_new, atoms+0.005, rtol=1e-4, atol=1e-4)\nassert np.allclose(velocities_new, velocities+0.1, rtol=1e-4, atol=1e-4)\nassert np.isclose(epot_new, -7777, rtol=1e-4, atol=1e-4)",
        "# case 3 - random force directions\ndef calculate_potential_energy_periodic(atoms, latvec, rcut):\n  return 1.345, np.array([[1,  -1,  1, ],\n [1 ,1 ,1 ],\n [-1,1,1],\n [1,1,-1]])\natoms = np.array([[0.,  0.,  0., ],\n [0.5 ,0.5 ,0. ],\n [0.  ,0.5, 0.5],\n [0.5 ,0.  ,0.5]])\nlatcnt = (2**(1/6)*np.sqrt(2))\natoms *=latcnt\nlatvec = np.identity(3)*latcnt\nvelocities = np.ones((len(atoms),3))\natoms_new, velocities_new, epot_new = velocity_verlet_update(\n    atoms, velocities, latvec, 0.1, 1.3)\nassert np.allclose(atoms_new-atoms, np.array([[0.105, 0.095, 0.105],\n       [0.105, 0.105, 0.105],\n       [0.095, 0.105, 0.105],\n       [0.105, 0.105, 0.095]]), rtol=1e-4, atol=1e-4)\nassert np.allclose(velocities_new-velocities, np.array([[ 0.1, -0.1,  0.1],\n       [ 0.1,  0.1,  0.1],\n       [-0.1,  0.1,  0.1],\n       [ 0.1,  0.1, -0.1]]), rtol=1e-4, atol=1e-4)\nassert np.isclose(epot_new, 1.345, rtol=1e-4, atol=1e-4)",
        "# case 4 - random force and velocities\ndef calculate_potential_energy_periodic(atoms, latvec, rcut):\n  return 9.876, np.array([[-1,  0,  1],\n       [ 1,  0, -2],\n       [-1, -1, -1],\n       [-1, -2, -1]])\natoms = np.array([[0.,  0.,  0., ],\n [0.5 ,0.5 ,0. ],\n [0.  ,0.5, 0.5],\n [0.5 ,0.  ,0.5]])\nlatcnt = (2**(1/6)*np.sqrt(2))\natoms *=latcnt\nlatvec = np.identity(3)*latcnt\nvelocities = np.array([[0, 1, 0],\n       [1, 1, 2],\n       [0, 2, 0],\n       [0, 0, 2]])\natoms_new, velocities_new, epot_new = velocity_verlet_update(\n    atoms, velocities, latvec, 0.1, 1.3)\nassert np.allclose(atoms_new-atoms, np.array([[-0.005,  0.1  ,  0.005],\n       [ 0.105,  0.1  ,  0.19 ],\n       [-0.005,  0.195, -0.005],\n       [-0.005, -0.01 ,  0.195]]), rtol=1e-4, atol=1e-4)\nassert np.allclose(velocities_new-velocities, np.array([[-0.1,  0. ,  0.1],\n       [ 0.1,  0. , -0.2],\n       [-0.1, -0.1, -0.1],\n       [-0.1, -0.2, -0.1]]), rtol=1e-4, atol=1e-4)\nassert np.isclose(epot_new, 9.876, rtol=1e-4, atol=1e-4)"
      ]
    },
    {
      "step_number": "51.3",
      "step_name": "velocity_verlet",
      "step_description_prompt": "Implement the velocity verlet algorithm to simulate a system of particles interacting through a Lennard-Jones potential. Assume that the particles are in a periodic system, and we'll use the continuous version of the Lennard-Jones potential where the potential is set to 0 after a cutoff distance $r_c$.\nWrite a function that takes the position and velocities of the particles in the system, the lattice constants of computational cell, integration time step and the cutoff distance $r_c$ as inputs, outputs the updated position and velocity as outputs.\nFor simplicity, use Lennard-Jones units given by energy  $\\epsilon$, length $\\sigma$, and the atom mass $m$.  For example, units of time are $m^\\frac{1}{2}\\sigma\\epsilon^{-\\frac{1}{2}}.$\n",
      "step_background": "The continuous version of the Lennard-Jones potential is\n\\begin{equation}\n\\phi(r) =\n\\begin{cases}\n4\\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12}-\\left(\\frac{\\sigma}{r}\\right)^6\\right]-4\\epsilon\\left[\\left(\\frac{\\sigma}{r_c}\\right)^{12}-\\left(\\frac{\\sigma}{r_c}\\right)^6\\right], & r<r_c \\\\\n 0, & r\\ge r_c\n \\end{cases}\n \\end{equation}\n\n\nThe velocity verlet algorithm updates are given by the equations below. \\\nGiven the set of positions of velocities of all particles in a N-atom system at time t, \\\nthe positions, forces, and velocities at time t+dt are computed as follows:\n\n1. Calculate for all atoms $l$, \n\\begin{equation}\n\\vec{r_l}(t+dt) = \\vec{r_l}(t) + \\vec{v_l}(t)dt + \\frac{1}{2}\\frac{\\vec{f_l}(t)}{m_l}dt^2\n\\end{equation}\n\n2. Calculate for all atoms $l$,\n\\begin{equation}\n\\vec{f_l}(t+dt) = -\\vec{\\nabla_l}E_{pot}(\\vec{r_1}(t+dt), ... , \\vec{r_N}(t+dt))\n\\end{equation}\n\n3. Calculate for all atoms $l$,\n\\begin{equation}\n\\vec{v_l}(t+dt) = \\vec{v_l}(t) + \\frac{\\vec{f_l}(t+dt)+\\vec{f_l}(t)}{2m_l} dt\n\\end{equation}\n\nwhere $\\vec{r_l}$, $\\vec{f_l}$, $\\vec{v_l}$, $m_l$ are the position, force, velocity and mass of the l-th particle in the system. $E_{pot}$ is the potential energy.\n",
      "ground_truth_code": "def velocity_verlet(\n    atoms:np.ndarray, \n    velocities:np.ndarray, \n    latvec:np.ndarray, \n    dt:float, \n    rcut:float,\n    n_steps:int\n) -> tuple[np.ndarray, np.ndarray, np.ndarray]:\n  '''Implementation of an MD simulation of a Lennard-Jones system using velocity verlet.\n  \n  Args:\n    atoms: positions of each atom of shape (n_atoms, 3)\n    velocities: velocities of each atom of shape (n_atoms, 3)\n    latvec: Lattice vectors of the computational cell.\n    dt: time step for the velocity verlet integration.\n    rcut: cutoff distance for the continuous Lennard-Jones potential.\n    n_steps: number of time steps to simulate.\n  Returns:\n    atoms_trajectory: atom positions at each step of the simulation. Shape (n_atoms, 3, n_steps)\n    velocities_new: atom velocities at each step of the simulation. Shape (n_atoms, 3, n_steps)\n    E_pot_new: potential energy of the system at each step of the simulation. Shape (n_steps,)\n  '''\n  atoms_trajectory = []\n  velocities_trajectory = []\n  E_pot_trajectory = []\n  for _ in range(n_steps):\n    atoms, velocities, E_pot = velocity_verlet_update(atoms, velocities, latvec, dt, rcut)\n    atoms_trajectory.append(atoms)\n    velocities_trajectory.append(velocities)\n    E_pot_trajectory.append(E_pot)\n  return np.array(atoms_trajectory), np.array(velocities_trajectory), np.array(E_pot_trajectory)\n\ndef velocity_verlet_update(\n    atoms:np.ndarray, \n    velocities:np.ndarray, \n    latvec:np.ndarray, \n    dt:float, \n    rcut:float\n) -> tuple[np.ndarray, np.ndarray, float]:\n  '''One update step of the velocity verlet algorithm.\n\n  Args:\n    atoms: positions of each atom of shape (n_atoms, 3)\n    velocities: velocities of each atom of shape (n_atoms, 3)\n    latvec: Lattice vectors of the computational cell.\n    dt: time step for the velocity verlet integration.\n    rcut: cutoff distance for the continuous Lennard-Jones potential.\n  Returns:\n    atoms_new: updated atom positions of shape (n_atoms, 3)\n    velocities_new: updated velocities of shape (n_atoms, 3)\n    E_pot_new: updated potential energy of the system\n  '''\n  E_pot, forces = calculate_potential_energy_periodic(atoms, latvec, rcut)\n  atoms_new = atoms + velocities*dt + 0.5*forces*dt*dt\n  E_pot_new, forces_new = calculate_potential_energy_periodic(atoms_new, latvec, rcut)\n  velocities_new = velocities + 0.5*(forces_new+forces)*dt\n  return atoms_new, velocities_new, E_pot_new\n\n\ndef calculate_potential_energy_periodic(\n    atoms: np.ndarray,\n    latvec: np.ndarray,\n    rcut: float\n) -> tuple[float, np.ndarray]:\n  '''Calculate the potential energy and forces on a system of atoms in a periodic system.\n\n  Args:\n    atoms: positions of each atom of shape (n_atoms, 3)\n    latvec: Lattice vectors of the computational cell.\n    rcut: cutoff distance for the continuous Lennard-Jones potential.\n\n  Returns:\n    total energy, forces of shape (n_atoms, 3)\n  '''\n  l_max = np.ceil(rcut/latvec[0,0]).astype(int)\n  m_max = np.ceil(rcut/latvec[1,1]).astype(int)\n  n_max = np.ceil(rcut/latvec[2,2]).astype(int)\n  ecut = rcut**-12 - rcut**-6\n\n  e_tot = 0\n  forces = np.zeros((len(atoms),3))\n  for i in range(len(atoms)):\n    for j in range(len(atoms)):\n      for l in range(-l_max, l_max+1):\n        for m in range(-m_max, m_max+1):\n          for n in range(-n_max, n_max+1):\n            # latvec are row vectors\n            disp_ij = atoms[i]-atoms[j] + np.matmul(np.array([l,m,n]), latvec)\n            r_ij = np.linalg.norm(disp_ij)\n            if r_ij>0 and r_ij < rcut:\n              e_tot += -r_ij**-6 + r_ij**-12 - ecut\n              forces[i] += 24*(2*r_ij**-14 -r_ij**-8)*disp_ij\n  e_tot*=2\n  return e_tot, forces\n",
      "function_header": "def velocity_verlet(\n    atoms:np.ndarray, \n    velocities:np.ndarray, \n    latvec:np.ndarray, \n    dt:float, \n    rcut:float,\n    n_steps:int\n) -> tuple[np.ndarray, np.ndarray, np.ndarray]:\n  '''Implementation of an MD simulation of a Lennard-Jones system using velocity verlet.\n  \n  Args:\n    atoms: positions of each atom of shape (n_atoms, 3)\n    velocities: velocities of each atom of shape (n_atoms, 3)\n    latvec: Lattice vectors of the computational cell.\n    dt: time step for the velocity verlet integration.\n    rcut: cutoff distance for the continuous Lennard-Jones potential.\n    n_steps: number of time steps to simulate.\n  Returns:\n    atoms_trajectory: atom positions at each step of the simulation. Shape (n_atoms, 3, n_steps)\n    velocities_new: atom velocities at each step of the simulation. Shape (n_atoms, 3, n_steps)\n    E_pot_new: potential energy of the system at each step of the simulation. Shape (n_steps,)\n  '''",
      "test_cases": [
        "# test 1 - 2x2x2 FCC crystal at initial T=0.2\n# rtol and atol are adjusted on a case-by-case basis\ndef calculate_E_kin(velocities):\n  return 0.5 * np.linalg.norm(velocities)**2\n\ndef calculate_T(velocities):\n  E_kin = calculate_E_kin(velocities)\n  T = E_kin*2/(3*len(velocities))\n  return T\n\ndef initialize_velocities(n_atoms, T_target=None):\n  np.random.seed(0)\n  velocities = np.random.uniform(-1,1,(n_atoms,3))\n  if T_target is not None:\n    velocities*=np.sqrt(T_target/calculate_T(velocities))\n  return velocities\n\natoms = np.array([[0.        , 0.        , 0.        ],\n       [0.79370053, 0.79370053, 0.        ],\n       [0.        , 0.79370053, 0.79370053],\n       [0.79370053, 0.        , 0.79370053],\n       [0.        , 0.        , 1.58740105],\n       [0.79370053, 0.79370053, 1.58740105],\n       [0.        , 0.79370053, 2.38110158],\n       [0.79370053, 0.        , 2.38110158],\n       [0.        , 1.58740105, 0.        ],\n       [0.79370053, 2.38110158, 0.        ],\n       [0.        , 2.38110158, 0.79370053],\n       [0.79370053, 1.58740105, 0.79370053],\n       [0.        , 1.58740105, 1.58740105],\n       [0.79370053, 2.38110158, 1.58740105],\n       [0.        , 2.38110158, 2.38110158],\n       [0.79370053, 1.58740105, 2.38110158],\n       [1.58740105, 0.        , 0.        ],\n       [2.38110158, 0.79370053, 0.        ],\n       [1.58740105, 0.79370053, 0.79370053],\n       [2.38110158, 0.        , 0.79370053],\n       [1.58740105, 0.        , 1.58740105],\n       [2.38110158, 0.79370053, 1.58740105],\n       [1.58740105, 0.79370053, 2.38110158],\n       [2.38110158, 0.        , 2.38110158],\n       [1.58740105, 1.58740105, 0.        ],\n       [2.38110158, 2.38110158, 0.        ],\n       [1.58740105, 2.38110158, 0.79370053],\n       [2.38110158, 1.58740105, 0.79370053],\n       [1.58740105, 1.58740105, 1.58740105],\n       [2.38110158, 2.38110158, 1.58740105],\n       [1.58740105, 2.38110158, 2.38110158],\n       [2.38110158, 1.58740105, 2.38110158]])\nlatcnt = (2**(1/6)*np.sqrt(2))\nlatvec = np.identity(3)*latcnt*np.array([2,2,2])\nvelocities = initialize_velocities(len(atoms), T_target=0.2)\ndt, rcut = 0.01, 1.3\natoms_traj, velocities_traj, E_pot_traj = velocity_verlet(atoms, velocities, latvec, dt, rcut, 100)\n# temperature should equilibrate after ~50 steps to ~0.1\nTs = [calculate_T(velocities) for velocities in velocities_traj]\nassert np.isclose(np.mean(Ts[50:]),0.1, rtol=2e-2, atol=2e-2)\n# total energy should not drift\ntotal_energies = [E_pot_traj[i]+calculate_E_kin(velocities_traj[i]) for i in range(len(velocities_traj))]\nassert np.allclose(np.array(total_energies)/-56.25,np.ones(100),rtol=1e-3,atol=1e-3)",
        "# test 2 - 1x1x1 FCC crystal at initial T=0.2, single vacancy\n# rtol and atol are adjusted on a case-by-case basis\ndef calculate_E_kin(velocities):\n  return 0.5 * np.linalg.norm(velocities)**2\n\ndef calculate_T(velocities):\n  E_kin = calculate_E_kin(velocities)\n  T = E_kin*2/(3*len(velocities))\n  return T\n\ndef initialize_velocities(n_atoms, T_target=None):\n  np.random.seed(0)\n  velocities = np.random.uniform(-1,1,(n_atoms,3))\n  if T_target is not None:\n    velocities*=np.sqrt(T_target/calculate_T(velocities))\n  return velocities\n\natoms = np.array([[0.79370053, 0.79370053, 0.        ],\n       [0.        , 0.79370053, 0.79370053],\n       [0.79370053, 0.        , 0.79370053]])\nlatcnt = (2**(1/6)*np.sqrt(2))\nlatvec = np.identity(3)*latcnt*np.array([2,2,2])\nvelocities = np.array([[-0.1,-0.05,0],[0.1,0.05,-0.1],[0.05,-0.1,0.1]])\ndt, rcut = 0.01, 1.3\natoms_traj, velocities_traj, E_pot_traj = velocity_verlet(atoms, velocities, latvec, dt, rcut, 100)\nassert np.allclose(atoms_traj[-1], np.array([[ 0.78820291,  0.68950762, -0.04011873],\n       [ 0.04147958,  0.80786198,  0.78855439],\n       [ 0.80771856, -0.00996855,  0.8389654 ]]),rtol=1e-3,atol=1e-3)",
        "# test 3 - 2x2x2 FCC crystal at initial T=0.2, large time step\n# rtol and atol are adjusted on a case-by-case basis\ndef calculate_E_kin(velocities):\n  return 0.5 * np.linalg.norm(velocities)**2\n\ndef calculate_T(velocities):\n  E_kin = calculate_E_kin(velocities)\n  T = E_kin*2/(3*len(velocities))\n  return T\n\ndef initialize_velocities(n_atoms, T_target=None):\n  np.random.seed(0)\n  velocities = np.random.uniform(-1,1,(n_atoms,3))\n  if T_target is not None:\n    velocities*=np.sqrt(T_target/calculate_T(velocities))\n  return velocities\n\natoms = np.array([[0.        , 0.        , 0.        ],\n       [0.79370053, 0.79370053, 0.        ],\n       [0.        , 0.79370053, 0.79370053],\n       [0.79370053, 0.        , 0.79370053],\n       [0.        , 0.        , 1.58740105],\n       [0.79370053, 0.79370053, 1.58740105],\n       [0.        , 0.79370053, 2.38110158],\n       [0.79370053, 0.        , 2.38110158],\n       [0.        , 1.58740105, 0.        ],\n       [0.79370053, 2.38110158, 0.        ],\n       [0.        , 2.38110158, 0.79370053],\n       [0.79370053, 1.58740105, 0.79370053],\n       [0.        , 1.58740105, 1.58740105],\n       [0.79370053, 2.38110158, 1.58740105],\n       [0.        , 2.38110158, 2.38110158],\n       [0.79370053, 1.58740105, 2.38110158],\n       [1.58740105, 0.        , 0.        ],\n       [2.38110158, 0.79370053, 0.        ],\n       [1.58740105, 0.79370053, 0.79370053],\n       [2.38110158, 0.        , 0.79370053],\n       [1.58740105, 0.        , 1.58740105],\n       [2.38110158, 0.79370053, 1.58740105],\n       [1.58740105, 0.79370053, 2.38110158],\n       [2.38110158, 0.        , 2.38110158],\n       [1.58740105, 1.58740105, 0.        ],\n       [2.38110158, 2.38110158, 0.        ],\n       [1.58740105, 2.38110158, 0.79370053],\n       [2.38110158, 1.58740105, 0.79370053],\n       [1.58740105, 1.58740105, 1.58740105],\n       [2.38110158, 2.38110158, 1.58740105],\n       [1.58740105, 2.38110158, 2.38110158],\n       [2.38110158, 1.58740105, 2.38110158]])\nlatcnt = (2**(1/6)*np.sqrt(2))\nlatvec = np.identity(3)*latcnt*np.array([2,2,2])\nvelocities = initialize_velocities(len(atoms), T_target=0.2)\ndt, rcut = 0.2, 1.3\natoms_traj, velocities_traj, E_pot_traj = velocity_verlet(atoms, velocities, latvec, dt, rcut, 100)\nassert np.allclose(atoms_traj[-1], np.array([[ 0.78820291,  0.68950762, -0.04011873],\n       [ 0.04147958,  0.80786198,  0.78855439],\n       [ 0.80771856, -0.00996855,  0.8389654 ]]),rtol=1e-3,atol=1e-3)"
      ]
