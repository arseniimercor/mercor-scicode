{
    "problem_id": "19",
    "problem_name": "n_tangle",
    "problem_description_main": "Write a function that returns the tensor product of $n$ Pauli Y matrices. Using this function, compute the $n$-tangle of an n-qubit pure state, $|\\psi\\rangle$, for even $n$, where $|\\psi\\rangle$ is a complex vector of length $2^n$. The $n$-tangle is a measure of multi-qubit entanglement.",
    "problem_background_main": "The $n$-tangle of an $n$-qubit pure state $|\\psi\\rangle$ (for even $n$) is defined as:\n\n$\\tau_n = |\\langle \\psi^* | \\sigma_y^{\\otimes n} | \\psi \\rangle|^2$.",
    "problem_io": "def n_tangle(psi, product = None) -> float:\n    \"\"\"\n    Args:\n        psi (np.ndarray): A 1D array of complex numbers representing the state vector.\n        product (np.ndarray, optional): The tensor product of n Pauli Y matrices.\n\n    Returns:\n        float: The n-tangle of the state, psi.\n\n    Raises:\n        ValueError: If n is not even.\n    \"\"\"\n",
    "required_dependencies": "import numpy as np",
    "sub_steps": [
        {
            "step_number": "19.1",
            "step_name": "sigma_y_tensor_power",
            "step_description_prompt": "Write a function that computes the tensor (Kronecker) product of $n$ Pauli Y matrices.",
            "step_background": "",
            "ground_truth_code": "def sigma_y_tensor_power(n) -> np.ndarray:\n    \"\"\"\n    Compute the tensor product of n Pauli Y matrices.\n\n    Args:\n        n (int): Number of matrices.\n\n    Returns:\n        np.ndarray: The tensor product of n Pauli Y matrices.\n    \"\"\"\n    sigma_y = np.array([[0,-1j],[1j,0]])\n    if n == 1:\n        return sigma_y\n    product = sigma_y\n    for _ in range(n-1):\n        product = np.kron(product, sigma_y)\n    return product",
            "function_header": "def sigma_y_tensor_power(n) -> np.ndarray:\n    \"\"\"\n    Compute the tensor product of n Pauli Y matrices.\n\n    Args:\n        n (int): Number of matrices.\n\n    Returns:\n        np.ndarray: The tensor product of n Pauli Y matrices.\n    \"\"\"\n",
            "test_cases": [
                "# Test 1: n = 1\ntarget = np.array([[0,-1j],[1j,0]])\nassert np.allclose(sigma_y_tensor_power(1), target, rtol=1e-4, atol=1e-4)",
                "# Test 2: n = 2\nn = 2\nsigma_y = np.array([[0,-1j],[1j,0]])\nassert np.allclose(sigma_y_tensor_power(2), np.kron(sigma_y, sigma_y), rtol=1e-4, atol=1e-4)",
                "# Test 3: n = 3\nn = 3\nsigma_y = np.array([[0,-1j],[1j,0]])\ntarget = sigma_y\nfor _ in range(n-1):\n    target = np.kron(target, sigma_y)\nassert np.allclose(sigma_y_tensor_power(n), target, rtol=1e-4, atol=1e-4)",
                "# Test 4: n = 4\nn = 4\nsigma_y = np.array([[0,-1j],[1j,0]])\ntarget = sigma_y\nfor _ in range(n-1):\n    target = np.kron(target, sigma_y)\nassert np.allclose(sigma_y_tensor_power(n), target, rtol=1e-4, atol=1e-4)",
                "# Test 5: n = 5\nn = 5\nsigma_y = np.array([[0,-1j],[1j,0]])\ntarget = sigma_y\nfor _ in range(n-1):\n    target = np.kron(target, sigma_y)\nassert np.allclose(sigma_y_tensor_power(n), target, rtol=1e-4, atol=1e-4)",
                "# Test 6: n = 6\nn = 6\nsigma_y = np.array([[0,-1j],[1j,0]])\ntarget = sigma_y\nfor _ in range(n-1):\n    target = np.kron(target, sigma_y)\nassert np.allclose(sigma_y_tensor_power(n), target, rtol=1e-4, atol=1e-4)",
                "# Test 7: n = 7\nn = 7\nsigma_y = np.array([[0,-1j],[1j,0]])\ntarget = sigma_y\nfor _ in range(n-1):\n    target = np.kron(target, sigma_y)\nassert np.allclose(sigma_y_tensor_power(n), target, rtol=1e-4, atol=1e-4)"
            ],
            "return_line": ""
        },
        {
            "step_number": "19.2",
            "step_name": "n_tangle",
            "step_description_prompt": "Compute the $n$-tangle of a $n$-qubit pure state $\\psi\\rangle$ where $n$ is even. The input is psi, a $2^n$ dimensional array of complex-valued numbers. The output is the $n$-tangle of the state, which is a float.",
            "step_background": "The $n$-tangle of an $n$-qubit pure state $|\\psi\\rangle$ is defined for even $n$ as:\n\n$\\tau_n = |\\langle \\psi^* | \\sigma_y^{\\otimes n} | \\psi \\rangle|^2$\n\nwhere $\\sigma_y$ is the Pauli Y matrix and $\\sigma_y^{\\otimes n}$ denotes the tensor product of $\\sigma_y$ with itself $n$ times.",
            "ground_truth_code": "def n_tangle(psi, product = None) -> float:\n    \"\"\"\n    Compute the n-tangle of an n-qubit pure state for even n.\n\n    Args:\n        psi (np.ndarray): A 1D array of complex numbers representing the state vector.\n        product (np.ndarray, optional): The tensor product of n Pauli Y matrices.\n\n    Returns:\n        float: The n-tangle of the state, psi.\n\n    Raises:\n        ValueError: If n is not even.\n    \"\"\"\n    if product is None:\n        n = int(np.log2(len(psi)))\n        if n % 2 != 0:\n            raise ValueError(\"n must be an even number.\")\n        product = sigma_y_tensor_power(n)\n    psi_star = product @ psi\n    tangle = (abs(np.vdot(np.conj(psi), psi_star)))**2\n    return tangle",
            "function_header": "def n_tangle(psi, product = None) -> float:\n    \"\"\"\n    Compute the n-tangle of an n-qubit pure state for even n.\n\n    Args:\n        psi (np.ndarray): A 1D array of complex numbers representing the state vector.\n        product (np.ndarray, optional): The tensor product of n Pauli Y matrices.\n\n    Returns:\n        float: The n-tangle of the state, psi.\n\n    Raises:\n        ValueError: If n is not even.\n    \"\"\"\n",
            "test_cases": [
                "# Test 1: 2-qubit maximally entangled state (|00⟩ + |11⟩)/√2\npsi = np.array([1, 0, 0, 1]) / np.sqrt(2)\nsigma_y = np.array([[0,-1j],[1j,0]])\nproduct = np.kron(sigma_y, sigma_y)\ntarget = 1.0\nassert np.isclose(n_tangle(psi, product), target, rtol=1e-4, atol=1e-4)",
                "# Test 2: 4-qubit GHZ state (|0000⟩ + |1111⟩)/√2\npsi = np.zeros(16, dtype=complex)\npsi[0] = 1/np.sqrt(2)\npsi[15] = 1/np.sqrt(2)\nsigma_y = np.array([[0,-1j],[1j,0]])\nproduct = sigma_y\nfor _ in range(3):\n    product = np.kron(product, sigma_y)\ntarget = 1.0\nassert np.isclose(n_tangle(psi, product), target, rtol=1e-4, atol=1e-4)",
                "# Test 3: 4-qubit W state (|0001⟩ + |0010⟩ + |0100⟩ + |1000⟩)/2\npsi = np.zeros(16, dtype=complex)\npsi[1] = 1/2\npsi[2] = 1/2\npsi[4] = 1/2\npsi[8] = 1/2\nsigma_y = np.array([[0,-1j],[1j,0]])\nproduct = sigma_y\nfor _ in range(3):\n    product = np.kron(product, sigma_y)\ntarget = 0.0\nassert np.isclose(n_tangle(psi, product), target, rtol=1e-4, atol=1e-4)",
                "# Test 4: 2-qubit product state |01⟩ (no entanglement)\npsi = np.kron([0, 1], [0.8, 0.6])\nsigma_y = np.array([[0,-1j],[1j,0]])\nproduct = np.kron(sigma_y, sigma_y)\ntarget = 0.0\nassert np.isclose(n_tangle(psi, product), target, rtol=1e-4, atol=1e-4)",
                "# Test 5: Product state with complex-valued amplitudes (1/2)*|00⟩ + (1/2)*|01⟩ + (i/2)*|10⟩ + (i/2)*|11⟩\npsi = np.array([1/2, 1/2, 1j/2, 1j/2])\nsigma_y = np.array([[0,-1j],[1j,0]])\nproduct = np.kron(sigma_y, sigma_y)\ntarget = 0.0\nassert np.isclose(n_tangle(psi, product), target, rtol=1e-4, atol=1e-4)",
                "# Test 6: Perfectly entangled state with complex amplitudes (|00> + i|11>)/√2\npsi = np.array([1,0,0,1j]/np.sqrt(2), dtype = complex)\nsigma_y = np.array([[0,-1j],[1j,0]])\nproduct = np.kron(sigma_y, sigma_y)\ntarget=1.0\nassert np.isclose(n_tangle(psi, product), target, rtol=1e-4, atol=1e-4)",
                "# Test 7: Sweep of 2-qubit states with varying levels of entanglement\nalpha = np.linspace(0, np.pi/2, 10)\ntarget = [0.0, 0.11697777844051092, 0.41317591116653485, 0.7499999999999999, 0.9698463103929539,\n0.9698463103929543, 0.7500000000000003, 0.413175911166535, 0.11697777844051105, 1.4997597826618576e-32]\nsigma_y = np.array([[0,-1j],[1j,0]])\nproduct = np.kron(sigma_y, sigma_y)\nfor i in range(len(target)):\n    psi = np.cos(alpha[i]) * np.array([1, 0, 0, 0]) + np.sin(alpha[i]) * np.array([0, 0, 0, 1])\n    assert np.isclose(target[i], n_tangle(psi, product), rtol=1e-4, atol=1e-4)",
                "# Test 8: 2-qubit partial entanglement with phase\npsi = np.array([np.sqrt(3/4),0,0,np.sqrt(1/4)*np.exp(1j*np.pi/4)])\nsigma_y = np.array([[0,-1j],[1j,0]])\nproduct = np.kron(sigma_y, sigma_y)\ntarget = 3/4\nassert np.isclose(n_tangle(psi, product), target, rtol=1e-4, atol=1e-4)",
                "# Test 9: 2-qubit partial entanglement example\na = 0.5\nraw_psi = np.array([1, a, a, 1], dtype=complex)\npsi = raw_psi / np.linalg.norm(raw_psi)\nsigma_y = np.array([[0,-1j],[1j,0]])\nproduct = np.kron(sigma_y, sigma_y)\ntarget = 0.36\nassert np.isclose(n_tangle(psi, product), target, rtol=1e-4, atol=1e-4)",
                "# Test 10: n-qubit equal superposition state for n in [2, 4, 6, 8, 10, 12]\ntarget=0.0\nsigma_y = np.array([[0,-1j],[1j,0]])\nproduct = sigma_y\nplus_state = np.array([1, 1]) / np.sqrt(2)\npsi = plus_state\nfor n in range(2, 13):\n    psi = np.kron(psi, plus_state)\n    product = np.kron(product, sigma_y)\n    if n % 2 == 0:\n        assert np.isclose(n_tangle(psi, product), target, rtol=1e-4, atol=1e-4)",
                "# Test 11: 4-qubit product states\nsigma_y = np.array([[0,-1j],[1j,0]])\nproduct = sigma_y\nfor _ in range(3):\n    product = np.kron(product, sigma_y)\nzero_state = np.array([1, 0])\none_state = np.array([0, 1])\ntarget = 0.0\nfor s1 in [zero_state, one_state]:\n    for s2 in [zero_state, one_state]:\n        for s3 in [zero_state, one_state]:\n            for s4 in [zero_state, one_state]:\n                psi = np.kron(np.kron(np.kron(s1, s2), s3), s4)\n                assert np.isclose(n_tangle(psi, product), target, rtol=1e-4, atol=1e-4)"
            ],
            "return_line": ""
        }
    ],
    "general_solution": "def sigma_y_tensor_power(n: int) -> np.ndarray:\n    \"\"\"\n    Compute the tensor product of n Pauli Y matrices.\n\n    Args:\n        n (int): Number of times to tensor the Pauli Y matrix.\n\n    Returns:\n        np.ndarray: The n-fold tensor product of the Pauli Y matrix.\n    \"\"\"\n    sigma_y = np.array([[0,-1j],[1j,0]])\n    if n == 1:\n        return sigma_y\n    product = sigma_y\n    for _ in range(n-1):\n        product = np.kron(product, sigma_y)\n    return product\ndef n_tangle(psi: np.ndarray, product: np.ndarray = None) -> float:\n    \"\"\"\n    Compute the n-tangle of an n-qubit pure state for even n.\n\n    Args:\n        psi (np.ndarray): A 1D array of complex numbers with length 2^n for n even.\n        product (np.ndarray, optional): The precomputed tensor product of n Pauli Y matrices. If None, it is computed.\n\n    Returns:\n        float: The n-tangle.\n\n    Raises:\n        ValueError: If n is not even.\n    \"\"\"\n    if product is None:\n        n = int(np.log2(len(psi)))\n        if n % 2 != 0:\n            raise ValueError(\"n must be an even number.\")\n        product = sigma_y_tensor_power(n)\n    psi_star = product @ psi\n    val = np.vdot(np.conj(psi), psi_star)\n    tangle = np.abs(val)**2\n    return tangle",
    "general_tests": [
        "# Test 1: 2-qubit maximally entangled state: (|00⟩ + |11⟩)/√2\npsi = np.array([1, 0, 0, 1]) / np.sqrt(2)\ntarget = 1.0\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
        "# Test 2: 4-qubit GHZ state:(|0000⟩ + |1111⟩)/√2\npsi = np.zeros(16, dtype=complex)\npsi[0] = 1/np.sqrt(2)\npsi[15] = 1/np.sqrt(2)\ntarget = 1.0\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
        "# Test 3: 4-qubit W state: (|0001⟩ + |0010⟩ + |0100⟩ + |1000⟩)/2\npsi = np.zeros(16, dtype=complex)\npsi[1] = 1/2\npsi[2] = 1/2\npsi[4] = 1/2\npsi[8] = 1/2\ntarget = 0.0\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
        "# Test 4: 2-qubit product state |01⟩ (no entanglement)\npsi = np.kron([0, 1], [0.8, 0.6])\ntarget = 0.0\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
        "# Test 5: Product state with complex-valued amplitudes (1/2)*|00⟩ + (1/2)*|01⟩ + (i/2)*|10⟩ + (i/2)*|11⟩\npsi = np.array([1/2, 1/2, 1j/2, 1j/2])\ntarget = 0.0\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
        "# Test 6: Perfectly entangled state with complex amplitudes (|00> + i|11>)/√2\npsi = np.array([1,0,0,1j]/np.sqrt(2), dtype = complex)\ntarget = 1.0\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
        "# Test 7: Sweep of 2-qubit states with varying levels of entanglement\nalpha = np.linspace(0, np.pi/2, 10)\ntarget = [0.0, 0.11697777844051092, 0.41317591116653485, 0.7499999999999999, 0.9698463103929539,\n0.9698463103929543, 0.7500000000000003, 0.413175911166535, 0.11697777844051105, 1.4997597826618576e-32]\nfor i in range(len(target)):\n    psi = np.cos(alpha[i]) * np.array([1, 0, 0, 0]) + np.sin(alpha[i]) * np.array([0, 0, 0, 1])\n    assert np.isclose(target[i], n_tangle(psi), rtol=1e-4, atol=1e-4)",
        "# Test 8: 2-qubit partial entanglement with phase\npsi = np.array([np.sqrt(3/4),0,0,np.sqrt(1/4)*np.exp(1j*np.pi/4)])\ntarget = 3/4\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
        "# Test 9: 2-qubit partial entanglement example\na = 0.5\nraw_psi = np.array([1, a, a, 1], dtype=complex)\npsi = raw_psi / np.linalg.norm(raw_psi)\ntarget = 0.36\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
        "# Test 10: n-qubit equal superposition state for n in [2, 4, 6, 8, 10, 12]\ntarget=0.0\nplus_state = np.array([1, 1]) / np.sqrt(2)\npsi = plus_state\nfor n in range(2, 13):\n    psi = np.kron(psi, plus_state)\n    if n % 2 == 0:\n        assert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
        "# Test 11: 4-qubit product states\nzero_state = np.array([1, 0])\none_state = np.array([0, 1])\ntarget = 0.0\nfor s1 in [zero_state, one_state]:\n    for s2 in [zero_state, one_state]:\n        for s3 in [zero_state, one_state]:\n            for s4 in [zero_state, one_state]:\n                psi = np.kron(np.kron(np.kron(s1, s2), s3), s4)\n                assert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)"
    ]
}
