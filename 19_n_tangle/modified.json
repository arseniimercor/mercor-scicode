{
    "problem_id": "19",
    "problem_name": "n_tangle",
    "problem_description_main": "Write a function that returns the tensor product of $n$ Pauli Y matrices. Using this function, compute the $n$-tangle of an n-qubit pure state, $|\\psi\\rangle$, for even $n$, represented as a complex vector of length $2^n$. The $n$-tangle, $\\tau_n$, is a measure of multi-qubit entanglement.",
    "problem_background_main": "The $n$-tangle of an $n$-qubit pure state $|\\psi\\rangle$ is defined for even $n$ as:\n\n$\\tau_n = |\\langle \\psi^* | \\sigma_y^{\\otimes n} | \\psi \\rangle|^2$\n\nwhere $\\sigma_y$ is the Pauli Y matrix and $\\sigma_y^{\\otimes n}$ denotes the tensor product of $\\sigma_y$ with itself $n$ times.",
    "problem_io": "'''\nArgs:\n    psi (np.ndarray): A 1D array of complex numbers representing the state vector.\n    product (np.ndarray, optional): The tensor product of n Pauli Y matrices.\n\nReturns\n    float: The n-tangle of the state, psi.\n\nRaises:\n    ValueError: Raises an exception.\n'''",
    "required_dependencies": "import numpy as np",
    "sub_steps": [
        {
            "step_number": "19.1",
            "step_name": "sigma_y_tensor_power",
            "step_description_prompt": "Write a function that computes the tensor (Kronecker) product of n Pauli Y matrices.",
            "step_background": "",
            "ground_truth_code": "def sigma_y_tensor_power(n) -> np.ndarray:\n    '''\n    Compute the tensor product of n Pauli Y matrices.\n\n    Args:\n        n (int): Number of matrices.\n\n    Returns:\n        np.ndarray: The tensor product of n Pauli Y matrices.\n\n    Raises:\n        ValueError: Raises an exception.\n    '''\n    if n <= 1:\n        raise ValueError(\"n must be greater than 1.\")\n    sigma_y = np.array([[0,-1j],[1j,0]])\n    product = sigma_y\n    for i in range(n-1):\n        product = np.kron(product, sigma_y)\n    return product",
            "function_header": "def sigma_y_tensor_power(n) -> np.ndarray:\n    '''\n    Compute the tensor product of n Pauli Y matrices.\n\n    Args:\n        n (int): Number of matrices.\n\n    Returns:\n        np.ndarray: The tensor product of n Pauli Y matrices.\n\n    Raises:\n        ValueError: Raises an exception.\n    '''",
            "test_cases": [
                "# Test 1: Tensor product of 2 Pauli Y matrices\nn=2\nsigma_y = np.array([[0,-1j],[1j,0]])\ntarget = np.kron(sigma_y, sigma_y)\nassert np.allclose(sigma_y_tensor_power(2), target, rtol=1e-4, atol=1e-4)",
                "# Test 2: Tensor product of 3 Pauli Y matrices\nn=3\nsigma_y = np.array([[0,-1j],[1j,0]])\ntarget = sigma_y\nfor i in range(2):\n        target = np.kron(target, sigma_y)\nassert np.allclose(sigma_y_tensor_power(3), target, rtol=1e-4, atol=1e-4)",
                "# Test 3: Tensor product of 4 Pauli Y matrices\nn=4\nsigma_y = np.array([[0,-1j],[1j,0]])\ntarget = sigma_y\nfor i in range(3):\n        target = np.kron(target, sigma_y)\nassert np.allclose(sigma_y_tensor_power(4), target, rtol=1e-4, atol=1e-4)",
                "# Test 4: Tensor product of 5 Pauli Y matrices\nn=5\nsigma_y = np.array([[0,-1j],[1j,0]])\ntarget = sigma_y\nfor i in range(4):\n        target = np.kron(target, sigma_y)\nassert np.allclose(sigma_y_tensor_power(5), target, rtol=1e-4, atol=1e-4)",
                "# Test 5: Tensor product of 6 Pauli Y matrices\nn=6\nsigma_y = np.array([[0,-1j],[1j,0]])\ntarget = sigma_y\nfor i in range(5):\n        target = np.kron(target, sigma_y)\nassert np.allclose(sigma_y_tensor_power(6), target, rtol=1e-4, atol=1e-4)"
            ],
            "return_line": ""
        },
        {
            "step_number": "19.2",
            "step_name": "n_tangle",
            "step_description_prompt": "Compute the $n$-tangle of a $n$-qubit pure state $\\psi\\rangle$ where $n$ is even. The input is psi, an $2^n$ dimensional array of floats. The output is the n-tangle of the state, which is a float.",
            "step_background": "The n-tangle of an n-qubit pure state $|\\psi\\rangle$ is defined for even $n$ as:\n\n$\\tau_n = |\\langle \\psi | \\sigma_y^{\\otimes n} | \\psi^* \\rangle|^2$\n\nwhere $\\sigma_y$ is the Pauli Y matrix and $\\sigma_y^{\\otimes n}$ denotes the tensor product of $\\sigma_y$ with itself $n$ times.",
            "ground_truth_code": "def n_tangle(psi, product = None) -> float:\n    '''\n    Compute the n-tangle of an n-qubit pure state for even n.\n\n    Args:\n        psi (np.ndarray): A 1D array of complex numbers representing the state vector.\n        product (np.ndarray, optional): The tensor product of n Pauli Y matrices.\n\n    Returns:\n        float: The n-tangle of the state, psi.\n\n    Raises:\n        ValueError: Raises an exception.\n    '''\n    if product is None:\n        n = int(np.log2(len(psi)))\n        if n % 2 != 0:\n            raise ValueError(\"n must be an even number.\")\n        product = sigma_y_tensor_power(n)\n    psi_star = product @ psi\n    tangle = (abs(np.inner(np.conj(psi), psi_star)))**2\n    return tangle",
            "function_header": "def n_tangle(psi, product = None) -> float:\n    '''\n    Compute the n-tangle of an n-qubit pure state for even n.\n\n    Args:\n        psi (np.ndarray): A 1D array of complex numbers representing the state vector.\n        product (np.ndarray, optional): The tensor product of n Pauli Y matrices.\n\n    Returns:\n        float: The n-tangle of the state, psi.\n\n    Raises:\n        ValueError: Raises an exception.\n    '''",
            "test_cases": [
                "# Test 1: 2-qubit maximally entangled Bell state |Φ+⟩ = (|00⟩ + |11⟩)/√2\npsi = np.array([1, 0, 0, 1]) / np.sqrt(2)\nsigma_y = np.array([[0,-1j],[1j,0]])\nproduct = np.kron(sigma_y, sigma_y)\ntarget = 1.0\nassert np.isclose(n_tangle(psi, product), target, rtol=1e-4, atol=1e-4)",
                "# Test 2: 4-qubit GHZ state |GHZ₄⟩ = (|0000⟩ + |1111⟩)/√2\npsi = np.zeros(16, dtype=complex)\npsi[0] = 1/np.sqrt(2)\npsi[15] = 1/np.sqrt(2)\nsigma_y = np.array([[0,-1j],[1j,0]])\nproduct = sigma_y\nfor i in range(3):\n    product = np.kron(product, sigma_y)\ntarget = 1.0\nassert np.isclose(n_tangle(psi, product), target, rtol=1e-4, atol=1e-4)",
                "# Test 3: 4-qubit W state |W₄⟩ = (|0001⟩ + |0010⟩ + |0100⟩ + |1000⟩)/2\npsi = np.zeros(16, dtype=complex)\npsi[1] = 1/2\npsi[2] = 1/2\npsi[4] = 1/2\npsi[8] = 1/2\nsigma_y = np.array([[0,-1j],[1j,0]])\nproduct = sigma_y\nfor i in range(3):\n    product = np.kron(product, sigma_y)\ntarget = 0.0\nassert np.isclose(n_tangle(psi, product), target, rtol=1e-4, atol=1e-4)",
                "# Test 4: Product state |01⟩ (no entanglement)\npsi = np.kron([0, 1], [0.8, 0.6])\nsigma_y = np.array([[0,-1j],[1j,0]])\nproduct = np.kron(sigma_y, sigma_y)\ntarget = 0.0\nassert np.isclose(n_tangle(psi, product), target, rtol=1e-4, atol=1e-4)",
                "# Test 5: Product state with complex-valued amplitudes (1/2)*|00⟩ + (1/2)*|01⟩ + (i/2)*|10⟩ + (i/2)*|11⟩\npsi = np.array([1/2, 1/2, 1j/2, 1j/2])\nsigma_y = np.array([[0,-1j],[1j,0]])\nproduct = np.kron(sigma_y, sigma_y)\ntarget = 0.0\nassert np.isclose(n_tangle(psi, product), target, rtol=1e-4, atol=1e-4)",
                "# Test 6: Sweep of 2-qubit states with varying levels of entanglement:\nalpha = np.linspace(0, np.pi/2, 10)\ntarget = [0.0, 0.11697777844051092, 0.41317591116653485, 0.7499999999999999, 0.9698463103929539,\n0.9698463103929543, 0.7500000000000003, 0.413175911166535, 0.11697777844051105, 1.4997597826618576e-32]\nsigma_y = np.array([[0,-1j],[1j,0]])\nproduct = np.kron(sigma_y, sigma_y)\nfor i in range(len(target)):\n    state = np.cos(alpha[i]) * np.array([1, 0, 0, 0]) + np.sin(alpha[i]) * np.array([0, 0, 0, 1])\n    assert np.isclose(target[i], n_tangle(state, product), rtol=1e-4, atol=1e-4)",
                "# Test 7: 2-qubit partial entanglement with phase:\npsi = np.array([np.sqrt(3/4),0,0,np.sqrt(1/4)*np.exp(1j*np.pi/4)])\nsigma_y = np.array([[0,-1j],[1j,0]])\nproduct = np.kron(sigma_y, sigma_y)\ntarget = 3/8\nassert np.isclose(n_tangle(psi, product), target, rtol=1e-4, atol=1e-4)"
            ],
            "return_line": ""
        }
    ],
    "general_solution": "def sigma_y_tensor_power(n) -> np.ndarray:\n    '''\n    Compute the tensor product of n Pauli Y matrices.\n\n    Args:\n        n (int): Number of matrices.\n\n    Returns:\n        np.ndarray: The tensor product of n Pauli Y matrices.\n    '''\n    if n <= 1:\n            raise ValueError(\"n must be greater than 1.\")\n    sigma_y = np.array([[0,-1j],[1j,0]])\n    product = sigma_y\n    for i in range(n-1):\n        product = np.kron(product, sigma_y)\n    return product\ndef n_tangle(psi, product = None) -> float:\n    '''\n    Compute the n-tangle of an n-qubit pure state for even n.\n\n    Args:\n        psi (np.ndarray): A 1D array of complex numbers representing the state vector.\n        product (np.ndarray, optional): The tensor product of n Pauli Y matrices.\n\n    Returns:\n        float: The n-tangle of the state, psi.\n\n    Raises:\n        ValueError: Raises an exception.\n    '''\n    if product is None:\n        n = int(np.log2(len(psi)))\n        if n % 2 != 0:\n                    raise ValueError(\"n must be an even number.\")\n        product = sigma_y_tensor_power(n)\n    psi_star = product @ psi\n    tangle = (abs(np.inner(np.conj(psi), psi_star)))**2\n    return tangle",
    "general_tests": [
        "# Test 1: 2-qubit maximally entangled Bell state |Φ+⟩ = (|00⟩ + |11⟩)/√2\npsi = np.array([1, 0, 0, 1]) / np.sqrt(2)\ntarget = 1.0\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
        "# Test 2: 4-qubit GHZ state |GHZ₄⟩ = (|0000⟩ + |1111⟩)/√2\npsi = np.zeros(16, dtype=complex)\npsi[0] = 1/np.sqrt(2)\npsi[15] = 1/np.sqrt(2)\ntarget = 1.0\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
        "# Test 3: 4-qubit W state |W₄⟩ = (|0001⟩ + |0010⟩ + |0100⟩ + |1000⟩)/2\npsi = np.zeros(16, dtype=complex)\npsi[1] = 1/2\npsi[2] = 1/2\npsi[4] = 1/2\npsi[8] = 1/2\ntarget = 0.0\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
        "# Test 4: Product state |01⟩ (no entanglement)\npsi = np.kron([0, 1], [0.8, 0.6])\ntarget = 0.0\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
        "# Test 5: Product state with complex-valued amplitudes (1/2)*|00⟩ + (1/2)*|01⟩ + (i/2)*|10⟩ + (i/2)*|11⟩\npsi = np.array([1/2, 1/2, 1j/2, 1j/2])\ntarget = 0.0\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
        "# Test 6: Sweep of 2-qubit states with varying levels of entanglement:\nalpha = np.linspace(0, np.pi/2, 10)\ntarget = [0.0, 0.11697777844051092, 0.41317591116653485, 0.7499999999999999, 0.9698463103929539,\n0.9698463103929543, 0.7500000000000003, 0.413175911166535, 0.11697777844051105, 1.4997597826618576e-32]\nfor i in range(len(target)):\n    state = np.cos(alpha[i]) * np.array([1, 0, 0, 0]) + np.sin(alpha[i]) * np.array([0, 0, 0, 1])\n    assert np.isclose(target[i], n_tangle(state), rtol=1e-4, atol=1e-4)",
        "# Test 7: 2-qubit partial entanglement with phase:\npsi = np.array([np.sqrt(3/4),0,0,np.sqrt(1/4)*np.exp(1j*np.pi/4)])\ntarget = 3/8\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)"
    ]
}
