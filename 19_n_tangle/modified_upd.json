{
    "problem_id": "19",
    "problem_name": "n_tangle",
    "problem_description_main": "Write a function that returns the tensor product of $n$ Pauli Y matrices. Using this function, compute the $n$-tangle of an n-qubit pure state, $|\\psi\\rangle$, for even $n$, where $|\\psi\\rangle$ is a complex vector of length $2^n$. The $n$-tangle is a measure of multi-qubit entanglement.",
    "problem_background_main": "The $n$-tangle of an $n$-qubit pure state $|\\psi\\rangle$ (for even $n$) is defined as:\n\n$\\tau_n = |\\langle \\psi^* | \\sigma_y^{\\otimes n} | \\psi \\rangle|^2$.",
    "problem_io": "def n_tangle(psi: np.ndarray) -> float:\n    \"\"\"\n    Args:\n        psi (np.ndarray): A 1D array of complex numbers representing the state vector.\n\n    Returns:\n        float: The n-tangle of the state, psi.\n\n    Raises:\n        ValueError: If n is not even.\n    \"\"\"\n",
    "required_dependencies": "import numpy as np",
    "sub_steps": [
        {
            "step_number": "19.1",
            "step_name": "sigma_y_tensor_power",
            "step_description_prompt": "Write a function that computes the tensor (Kronecker) product of $n$ Pauli Y matrices.",
            "step_background": "",
            "ground_truth_code": "def sigma_y_tensor_power(n: int) -> np.ndarray:\n    \"\"\"\n    Compute the tensor product of n Pauli Y matrices.\n\n    Args:\n        n (int): Number of matrices.\n\n    Returns:\n        np.ndarray: The tensor product of n Pauli Y matrices.\n    \"\"\"\n    sigma_y = np.array([[0,-1j],[1j,0]])\n    if n == 1:\n        return sigma_y\n    product = sigma_y\n    for _ in range(n-1):\n        product = np.kron(product, sigma_y)\n    return product",
            "function_header": "def sigma_y_tensor_power(n: int) -> np.ndarray:\n    \"\"\"\n    Compute the tensor product of n Pauli Y matrices.\n\n    Args:\n        n (int): Number of matrices.\n\n    Returns:\n        np.ndarray: The tensor product of n Pauli Y matrices.\n    \"\"\"\n",
            "test_cases": [
                "# Test 1: n = 1\nn = 1\ntarget = np.array([[0,-1j],[1j,0]])\nassert np.allclose(sigma_y_tensor_power(n), target, rtol=1e-4, atol=1e-4)",
                "# Test 2: n = 2\nn = 2\nsigma_y = np.array([[0,-1j],[1j,0]])\ntarget = np.kron(sigma_y, sigma_y)\nassert np.allclose(sigma_y_tensor_power(n), target, rtol=1e-4, atol=1e-4)",
                "# Test 3: n = 3\nn = 3\nsigma_y = np.array([[0,-1j],[1j,0]])\ntarget = sigma_y\nfor _ in range(n-1):\n    target = np.kron(target, sigma_y)\nassert np.allclose(sigma_y_tensor_power(n), target, rtol=1e-4, atol=1e-4)",
                "# Test 4: n = 4\nn = 4\nsigma_y = np.array([[0,-1j],[1j,0]])\ntarget = sigma_y\nfor _ in range(n-1):\n    target = np.kron(target, sigma_y)\nassert np.allclose(sigma_y_tensor_power(n), target, rtol=1e-4, atol=1e-4)",
                "# Test 5: n = 5\nn = 5\nsigma_y = np.array([[0,-1j],[1j,0]])\ntarget = sigma_y\nfor _ in range(n-1):\n    target = np.kron(target, sigma_y)\nassert np.allclose(sigma_y_tensor_power(n), target, rtol=1e-4, atol=1e-4)",
                "# Test 6: n = 6\nn = 6\nsigma_y = np.array([[0,-1j],[1j,0]])\ntarget = sigma_y\nfor _ in range(n-1):\n    target = np.kron(target, sigma_y)\nassert np.allclose(sigma_y_tensor_power(n), target, rtol=1e-4, atol=1e-4)",
                "# Test 7: n = 7\nn = 7\nsigma_y = np.array([[0,-1j],[1j,0]])\ntarget = sigma_y\nfor _ in range(n-1):\n    target = np.kron(target, sigma_y)\nassert np.allclose(sigma_y_tensor_power(n), target, rtol=1e-4, atol=1e-4)"
            ],
            "return_line": ""
        },
        {
            "step_number": "19.2",
            "step_name": "n_tangle",
            "step_description_prompt": "Compute the $n$-tangle of a $n$-qubit pure state $|\\psi\\rangle$ where $n$ is even. The input is psi, a $2^n$ dimensional array of complex-valued numbers. The output is the $n$-tangle of the state, which is a float. Assume you have access to a function sigma_y_tensor_power with the following docstring:\n\ndef sigma_y_tensor_power(n: int) -> np.ndarray:\n    \"\"\"\n    Compute the tensor product of n Pauli Y matrices.\n\n    Args:\n        n (int): Number of matrices.\n\n    Returns:\n        np.ndarray: The tensor product of n Pauli Y matrices.\n    \"\"\"\n",
            "step_background": "The $n$-tangle of an $n$-qubit pure state $|\\psi\\rangle$ is defined for even $n$ as:\n\n$\\tau_n = |\\langle \\psi^* | \\sigma_y^{\\otimes n} | \\psi \\rangle|^2$\n\nwhere $\\sigma_y$ is the Pauli Y matrix and $\\sigma_y^{\\otimes n}$ denotes the tensor product of $\\sigma_y$ with itself $n$ times.",
            "ground_truth_code": "def n_tangle(psi: np.ndarray) -> float:\n    \"\"\"\n    Compute the n-tangle of an n-qubit pure state for even n.\n\n    Args:\n        psi (np.ndarray): A 1D array of complex numbers representing the state vector.\n\n    Returns:\n        float: The n-tangle of the state, psi.\n\n    Raises:\n        ValueError: If n is not even.\n    \"\"\"\n    n = int(np.log2(len(psi)))\n    if n % 2 != 0:\n        raise ValueError(\"n must be an even number.\")\n    product = sigma_y_tensor_power(n)\n    psi_star = product @ psi\n    tangle = (np.abs(np.vdot(np.conj(psi), psi_star)))**2\n    return tangle",
            "function_header": "def n_tangle(psi: np.ndarray) -> float:\n    \"\"\"\n    Compute the n-tangle of an n-qubit pure state for even n.\n\n    Args:\n        psi (np.ndarray): A 1D array of complex numbers representing the state vector.\n\n    Returns:\n        float: The n-tangle of the state, psi.\n\n    Raises:\n        ValueError: If n is not even.\n    \"\"\"\n",
            "test_cases": [
                "# Test 1: 2-qubit maximally entangled state (|00⟩ + |11⟩)/√2\npsi = np.array([1, 0, 0, 1]) / np.sqrt(2)\ndef sigma_y_tensor_power(n):\n    sigma_y = np.array([[0,-1j],[1j,0]])\n    product = sigma_y\n    for _ in range(n-1):\n        product = np.kron(product, sigma_y)\n    return product\ntarget = 1.0\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
                "# Test 2: 4-qubit GHZ state (|0000⟩ + |1111⟩)/√2\npsi = np.zeros(16, dtype=complex)\npsi[0] = 1/np.sqrt(2)\npsi[15] = 1/np.sqrt(2)\ndef sigma_y_tensor_power(n):\n    sigma_y = np.array([[0,-1j],[1j,0]])\n    product = sigma_y\n    for _ in range(n-1):\n        product = np.kron(product, sigma_y)\n    return product\ntarget = 1.0\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
                "# Test 3: 4-qubit W state (|0001⟩ + |0010⟩ + |0100⟩ + |1000⟩)/2\npsi = np.zeros(16, dtype=complex)\npsi[1] = 1/2\npsi[2] = 1/2\npsi[4] = 1/2\npsi[8] = 1/2\ndef sigma_y_tensor_power(n):\n    sigma_y = np.array([[0,-1j],[1j,0]])\n    product = sigma_y\n    for _ in range(n-1):\n        product = np.kron(product, sigma_y)\n    return product\ntarget = 0.0\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
                "# Test 4: 2-qubit product state |01⟩ (no entanglement)\npsi = np.kron([0, 1], [0.8, 0.6])\ndef sigma_y_tensor_power(n):\n    sigma_y = np.array([[0,-1j],[1j,0]])\n    product = sigma_y\n    for _ in range(n-1):\n        product = np.kron(product, sigma_y)\n    return product\ntarget = 0.0\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
                "# Test 5: Product state with complex-valued amplitudes (1/2)*|00⟩ + (1/2)*|01⟩ + (i/2)*|10⟩ + (i/2)*|11⟩\npsi = np.array([1/2, 1/2, 1j/2, 1j/2])\ndef sigma_y_tensor_power(n):\n    sigma_y = np.array([[0,-1j],[1j,0]])\n    product = sigma_y\n    for _ in range(n-1):\n        product = np.kron(product, sigma_y)\n    return product\ntarget = 0.0\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
                "# Test 6: Perfectly entangled state with complex amplitudes (|00> + i|11>)/√2\npsi = np.array([1,0,0,1j]/np.sqrt(2), dtype = complex)\ndef sigma_y_tensor_power(n):\n    sigma_y = np.array([[0,-1j],[1j,0]])\n    product = sigma_y\n    for _ in range(n-1):\n        product = np.kron(product, sigma_y)\n    return product\ntarget=1.0\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
                "# Test 7: Sweep of 2-qubit states with varying levels of entanglement\nalpha = np.linspace(0, np.pi/2, 10)\ntarget = [0.0, 0.11697777844051092, 0.41317591116653485, 0.7499999999999999, 0.9698463103929539,\n0.9698463103929543, 0.7500000000000003, 0.413175911166535, 0.11697777844051105, 1.4997597826618576e-32]\ndef sigma_y_tensor_power(n):\n    sigma_y = np.array([[0,-1j],[1j,0]])\n    product = sigma_y\n    for _ in range(n-1):\n        product = np.kron(product, sigma_y)\n    return product\nfor i in range(len(target)):\n    psi = np.cos(alpha[i]) * np.array([1, 0, 0, 0]) + np.sin(alpha[i]) * np.array([0, 0, 0, 1])\n    assert np.isclose(target[i], n_tangle(psi), rtol=1e-4, atol=1e-4)",
                "# Test 8: 2-qubit partial entanglement with phase\npsi = np.array([np.sqrt(3/4),0,0,np.sqrt(1/4)*np.exp(1j*np.pi/4)])\ndef sigma_y_tensor_power(n):\n    sigma_y = np.array([[0,-1j],[1j,0]])\n    product = sigma_y\n    for _ in range(n-1):\n        product = np.kron(product, sigma_y)\n    return product\ntarget = 3/4\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
                "# Test 9: 2-qubit partial entanglement example\na = 0.5\nraw_psi = np.array([1, a, a, 1], dtype=complex)\npsi = raw_psi / np.linalg.norm(raw_psi)\ndef sigma_y_tensor_power(n):\n    sigma_y = np.array([[0,-1j],[1j,0]])\n    product = sigma_y\n    for _ in range(n-1):\n        product = np.kron(product, sigma_y)\n    return product\ntarget = 0.36\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
                "# Test 10: n-qubit equal superposition state for n in [2, 4, 6, 8, 10, 12]\ntarget=0.0\nsigma_y = np.array([[0,-1j],[1j,0]])\ndef sigma_y_tensor_power(n):\n    sigma_y = np.array([[0,-1j],[1j,0]])\n    product = sigma_y\n    for _ in range(n-1):\n        product = np.kron(product, sigma_y)\n    return product\nplus_state = np.array([1, 1]) / np.sqrt(2)\npsi = plus_state\nfor n in range(2, 13):\n    psi = np.kron(psi, plus_state)\n    if n % 2 == 0:\n        assert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
                "# Test 11: 4-qubit product states\ntarget = 0.0\nsigma_y = np.array([[0,-1j],[1j,0]])\ndef sigma_y_tensor_power(n):\n    sigma_y = np.array([[0,-1j],[1j,0]])\n    product = sigma_y\n    for _ in range(n-1):\n        product = np.kron(product, sigma_y)\n    return product\nzero_state = np.array([1, 0])\none_state = np.array([0, 1])\nfor s1 in [zero_state, one_state]:\n    for s2 in [zero_state, one_state]:\n        for s3 in [zero_state, one_state]:\n            for s4 in [zero_state, one_state]:\n                psi = np.kron(np.kron(np.kron(s1, s2), s3), s4)\n                assert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
                "# Test 12: 4-qubit Dicke state\ndef sigma_y_tensor_power(n):\n    sigma_y = np.array([[0,-1j],[1j,0]])\n    product = sigma_y\n    for _ in range(n-1):\n        product = np.kron(product, sigma_y)\n    return product\npsi = np.zeros(16, dtype=complex)\npsi[3] = 1/np.sqrt(6)\npsi[5] = 1/np.sqrt(6)\npsi[6] = 1/np.sqrt(6)\npsi[9] = 1/np.sqrt(6)\npsi[10] = 1/np.sqrt(6)\npsi[12] = 1/np.sqrt(6)\ntarget = 1.0\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
                "# Test 13: 2-qubit state with uniform, but unequal amplitudes\ndef sigma_y_tensor_power(n):\n    sigma_y = np.array([[0,-1j],[1j,0]])\n    product = sigma_y\n    for _ in range(n-1):\n        product = np.kron(product, sigma_y)\n    return product\npsi = np.array([1/2, 1j/2, -1/2, -1j/2])\ntarget = 0.0\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
                "# Test 14: 2-qubit states with randomly drawn amplitudes\ndef sigma_y_tensor_power(n):\n    sigma_y = np.array([[0,-1j],[1j,0]])\n    product = sigma_y\n    for _ in range(n-1):\n        product = np.kron(product, sigma_y)\n    return product\npsi = [np.array([0.60731022+0.51857487j, 0.35576829-0.24949737j, -0.03450109-0.33673503j, 0.16660792-0.17633881j]), np.array([0.03301026+0.57026862j, -0.1145051-0.00432118j, -0.70139757+0.00534534j, 0.07575743+0.40354383j]), np.array([0.37923824-0.46647498j, 0.09650552+0.53350158j, 0.3396389+0.27409151j, -0.13974712+0.36692262j]), np.array([-0.54807144+0.21920262j, 0.44828333-0.03780932j, -0.12008517+0.58147495j, -0.22793937-0.21140126j]), np.array([-0.13737289-0.47126141j, 0.28009167-0.21876921j, 0.47881411-0.13679999j, -0.5236888+0.3324198j ]), np.array([-0.41441998-0.19914807j, -0.26373462-0.60671454j, -0.23215514+0.46766318j, -0.03691636-0.27743462j]), np.array([0.12443468-0.53188955j, -0.52011158+0.16220139j, -0.36343026-0.0514628j, 0.29678862-0.42658025j]), np.array([0.34375555-0.38728172j, -0.50289056+0.33633058j, -0.50177916+0.0665955j, 0.32719373+0.05054488j])]\ntarget = [0.3666504743510322, 0.3910771870422996, 0.21462397918771778, 0.32391519789536116, 0.5357957009500679, 0.6365880161571263, 0.7279289585260391, 0.07286267551872663]\nfor i in range(8):\n    assert np.isclose(n_tangle(psi[i]), target[i], rtol=1e-4, atol=1e-4)",
                "# Test 15: entangled pairs within larger systems\ndef sigma_y_tensor_power(n):\n    sigma_y = np.array([[0,-1j],[1j,0]])\n    product = sigma_y\n    for _ in range(n-1):\n        product = np.kron(product, sigma_y)\n    return product\npsi = [np.array([1/np.sqrt(2), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1/np.sqrt(2), 0, 0, 0]), np.array([0, 0, 0, 0, 0, 0, 0, 1/np.sqrt(2), 0, 0, 0, 1/np.sqrt(2), 0, 0, 0, 0])]\ntarget=[0.0, 0.0]\nfor i in range(2):\n    assert np.isclose(n_tangle(psi[i]), target[i], rtol=1e-4, atol=1e-4)"
            ],
            "return_line": ""
        }
    ],
    "general_solution": "def sigma_y_tensor_power(n: int) -> np.ndarray:\n    \"\"\"\n    Compute the tensor product of n Pauli Y matrices.\n\n    Args:\n        n (int): Number of times to tensor the Pauli Y matrix.\n\n    Returns:\n        np.ndarray: The n-fold tensor product of the Pauli Y matrix.\n    \"\"\"\n    sigma_y = np.array([[0,-1j],[1j,0]])\n    if n == 1:\n        return sigma_y\n    product = sigma_y\n    for _ in range(n-1):\n        product = np.kron(product, sigma_y)\n    return product\ndef n_tangle(psi: np.ndarray) -> float:\n    \"\"\"\n    Compute the n-tangle of an n-qubit pure state for even n.\n\n    Args:\n        psi (np.ndarray): A 1D array of complex numbers with length 2^n for n even.\n\n    Returns:\n        float: The n-tangle.\n\n    Raises:\n        ValueError: If n is not even.\n    \"\"\"\n    n = int(np.log2(len(psi)))\n    if n % 2 != 0:\n        raise ValueError(\"n must be an even number.\")\n    product = sigma_y_tensor_power(n)\n    psi_star = product @ psi\n    tangle = (np.abs(np.vdot(np.conj(psi), psi_star)))**2\n    return tangle",
    "general_tests": [
        "# Test 1: 2-qubit maximally entangled state: (|00⟩ + |11⟩)/√2\npsi = np.array([1, 0, 0, 1]) / np.sqrt(2)\ntarget = 1.0\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
        "# Test 2: 4-qubit GHZ state:(|0000⟩ + |1111⟩)/√2\npsi = np.zeros(16, dtype=complex)\npsi[0] = 1/np.sqrt(2)\npsi[15] = 1/np.sqrt(2)\ntarget = 1.0\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
        "# Test 3: 4-qubit W state: (|0001⟩ + |0010⟩ + |0100⟩ + |1000⟩)/2\npsi = np.zeros(16, dtype=complex)\npsi[1] = 1/2\npsi[2] = 1/2\npsi[4] = 1/2\npsi[8] = 1/2\ntarget = 0.0\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
        "# Test 4: 2-qubit product state |01⟩ (no entanglement)\npsi = np.kron([0, 1], [0.8, 0.6])\ntarget = 0.0\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
        "# Test 5: Product state with complex-valued amplitudes (1/2)*|00⟩ + (1/2)*|01⟩ + (i/2)*|10⟩ + (i/2)*|11⟩\npsi = np.array([1/2, 1/2, 1j/2, 1j/2])\ntarget = 0.0\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
        "# Test 6: Perfectly entangled state with complex amplitudes (|00> + i|11>)/√2\npsi = np.array([1,0,0,1j]/np.sqrt(2), dtype = complex)\ntarget = 1.0\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
        "# Test 7: Sweep of 2-qubit states with varying levels of entanglement\nalpha = np.linspace(0, np.pi/2, 10)\ntarget = [0.0, 0.11697777844051092, 0.41317591116653485, 0.7499999999999999, 0.9698463103929539,\n0.9698463103929543, 0.7500000000000003, 0.413175911166535, 0.11697777844051105, 1.4997597826618576e-32]\nfor i in range(len(target)):\n    psi = np.cos(alpha[i]) * np.array([1, 0, 0, 0]) + np.sin(alpha[i]) * np.array([0, 0, 0, 1])\n    assert np.isclose(target[i], n_tangle(psi), rtol=1e-4, atol=1e-4)",
        "# Test 8: 2-qubit partial entanglement with phase\npsi = np.array([np.sqrt(3/4),0,0,np.sqrt(1/4)*np.exp(1j*np.pi/4)])\ntarget = 3/4\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
        "# Test 9: 2-qubit partial entanglement example\na = 0.5\nraw_psi = np.array([1, a, a, 1], dtype=complex)\npsi = raw_psi / np.linalg.norm(raw_psi)\ntarget = 0.36\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
        "# Test 10: n-qubit equal superposition state for n in [2, 4, 6, 8, 10, 12]\ntarget=0.0\nplus_state = np.array([1, 1]) / np.sqrt(2)\npsi = plus_state\nfor n in range(2, 13):\n    psi = np.kron(psi, plus_state)\n    if n % 2 == 0:\n        assert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
        "# Test 11: 4-qubit product states\ntarget = 0.0\nzero_state = np.array([1, 0])\none_state = np.array([0, 1])\nfor s1 in [zero_state, one_state]:\n    for s2 in [zero_state, one_state]:\n        for s3 in [zero_state, one_state]:\n            for s4 in [zero_state, one_state]:\n                psi = np.kron(np.kron(np.kron(s1, s2), s3), s4)\n                assert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
        "# Test 12: 4-qubit Dicke state\npsi = np.zeros(16, dtype=complex)\npsi[3] = 1/np.sqrt(6)\npsi[5] = 1/np.sqrt(6)\npsi[6] = 1/np.sqrt(6)\npsi[9] = 1/np.sqrt(6)\npsi[10] = 1/np.sqrt(6)\npsi[12] = 1/np.sqrt(6)\ntarget = 1.0\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
        "# Test 13: 2-qubit state with uniform, but unequal amplitudes\npsi = np.array([1/2, 1j/2, -1/2, -1j/2])\ntarget = 0.0\nassert np.isclose(n_tangle(psi), target, rtol=1e-4, atol=1e-4)",
        "# Test 14: 2-qubit states  with randomly drawn amplitudes\npsi = [np.array([0.60731022+0.51857487j, 0.35576829-0.24949737j, -0.03450109-0.33673503j, 0.16660792-0.17633881j]), np.array([0.03301026+0.57026862j, -0.1145051-0.00432118j, -0.70139757+0.00534534j, 0.07575743+0.40354383j]), np.array([0.37923824-0.46647498j, 0.09650552+0.53350158j, 0.3396389+0.27409151j, -0.13974712+0.36692262j]), np.array([-0.54807144+0.21920262j, 0.44828333-0.03780932j, -0.12008517+0.58147495j, -0.22793937-0.21140126j]), np.array([-0.13737289-0.47126141j, 0.28009167-0.21876921j, 0.47881411-0.13679999j, -0.5236888+0.3324198j ]), np.array([-0.41441998-0.19914807j, -0.26373462-0.60671454j, -0.23215514+0.46766318j, -0.03691636-0.27743462j]), np.array([0.12443468-0.53188955j, -0.52011158+0.16220139j, -0.36343026-0.0514628j, 0.29678862-0.42658025j]), np.array([0.34375555-0.38728172j, -0.50289056+0.33633058j, -0.50177916+0.0665955j, 0.32719373+0.05054488j])]\ntarget = [0.3666504743510322, 0.3910771870422996, 0.21462397918771778, 0.32391519789536116, 0.5357957009500679, 0.6365880161571263, 0.7279289585260391, 0.07286267551872663]\nfor i in range(8):\n    assert np.isclose(n_tangle(psi[i]), target[i], rtol=1e-4, atol=1e-4)",
        "# Test 15: entangled pairs within larger systems\npsi = [np.array([1/np.sqrt(2), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1/np.sqrt(2), 0, 0, 0]), np.array([0, 0, 0, 0, 0, 0, 0, 1/np.sqrt(2), 0, 0, 0, 1/np.sqrt(2), 0, 0, 0, 0])]\ntarget=[0.0, 0.0]\nfor i in range(2):\n    assert np.isclose(n_tangle(psi[i]), target[i], rtol=1e-4, atol=1e-4)"
    ]
}

